
I2MIDI_Interface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803f00  00803f00  00000692  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000061e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000099  00803f00  00803f00  00000692  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000692  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000006c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  00000700  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003c50  00000000  00000000  00000868  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001cf5  00000000  00000000  000044b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c3b  00000000  00000000  000061ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003e4  00000000  00000000  00006de8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000199c  00000000  00000000  000071cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007b1  00000000  00000000  00008b68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00009319  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	1b c0       	rjmp	.+54     	; 0x38 <__ctors_end>
   2:	34 c0       	rjmp	.+104    	; 0x6c <__bad_interrupt>
   4:	33 c0       	rjmp	.+102    	; 0x6c <__bad_interrupt>
   6:	32 c0       	rjmp	.+100    	; 0x6c <__bad_interrupt>
   8:	31 c0       	rjmp	.+98     	; 0x6c <__bad_interrupt>
   a:	30 c0       	rjmp	.+96     	; 0x6c <__bad_interrupt>
   c:	2f c0       	rjmp	.+94     	; 0x6c <__bad_interrupt>
   e:	2e c0       	rjmp	.+92     	; 0x6c <__bad_interrupt>
  10:	87 c1       	rjmp	.+782    	; 0x320 <__vector_8>
  12:	2c c0       	rjmp	.+88     	; 0x6c <__bad_interrupt>
  14:	2b c0       	rjmp	.+86     	; 0x6c <__bad_interrupt>
  16:	2a c0       	rjmp	.+84     	; 0x6c <__bad_interrupt>
  18:	29 c0       	rjmp	.+82     	; 0x6c <__bad_interrupt>
  1a:	51 c1       	rjmp	.+674    	; 0x2be <__vector_13>
  1c:	27 c0       	rjmp	.+78     	; 0x6c <__bad_interrupt>
  1e:	26 c0       	rjmp	.+76     	; 0x6c <__bad_interrupt>
  20:	25 c0       	rjmp	.+74     	; 0x6c <__bad_interrupt>
  22:	24 c0       	rjmp	.+72     	; 0x6c <__bad_interrupt>
  24:	23 c0       	rjmp	.+70     	; 0x6c <__bad_interrupt>
  26:	ef c0       	rjmp	.+478    	; 0x206 <__vector_19>
  28:	8a c0       	rjmp	.+276    	; 0x13e <__vector_20>
  2a:	20 c0       	rjmp	.+64     	; 0x6c <__bad_interrupt>
  2c:	36 c2       	rjmp	.+1132   	; 0x49a <__vector_22>
  2e:	a3 c2       	rjmp	.+1350   	; 0x576 <__vector_23>
  30:	1d c0       	rjmp	.+58     	; 0x6c <__bad_interrupt>
  32:	1c c0       	rjmp	.+56     	; 0x6c <__bad_interrupt>

00000034 <__ctors_start>:
  34:	31 01       	movw	r6, r2
  36:	fa 02       	muls	r31, r26

00000038 <__ctors_end>:
  38:	11 24       	eor	r1, r1
  3a:	1f be       	out	0x3f, r1	; 63
  3c:	cf ef       	ldi	r28, 0xFF	; 255
  3e:	cd bf       	out	0x3d, r28	; 61
  40:	df e3       	ldi	r29, 0x3F	; 63
  42:	de bf       	out	0x3e, r29	; 62

00000044 <__do_clear_bss>:
  44:	2f e3       	ldi	r18, 0x3F	; 63
  46:	a0 e0       	ldi	r26, 0x00	; 0
  48:	bf e3       	ldi	r27, 0x3F	; 63
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
  4e:	a9 39       	cpi	r26, 0x99	; 153
  50:	b2 07       	cpc	r27, r18
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>

00000054 <__do_global_ctors>:
  54:	10 e0       	ldi	r17, 0x00	; 0
  56:	cc e1       	ldi	r28, 0x1C	; 28
  58:	d0 e0       	ldi	r29, 0x00	; 0
  5a:	03 c0       	rjmp	.+6      	; 0x62 <__do_global_ctors+0xe>
  5c:	21 97       	sbiw	r28, 0x01	; 1
  5e:	fe 01       	movw	r30, r28
  60:	d6 d2       	rcall	.+1452   	; 0x60e <__tablejump2__>
  62:	ca 31       	cpi	r28, 0x1A	; 26
  64:	d1 07       	cpc	r29, r17
  66:	d1 f7       	brne	.-12     	; 0x5c <__do_global_ctors+0x8>
  68:	ee d1       	rcall	.+988    	; 0x446 <main>
  6a:	d7 c2       	rjmp	.+1454   	; 0x61a <_exit>

0000006c <__bad_interrupt>:
  6c:	c9 cf       	rjmp	.-110    	; 0x0 <__vectors>

0000006e <_Z8I2C_Initv>:
}

//Returns amount of data in RX buffer
uint8_t RXCountI2C(){
	return I2Cbuffer_RX.Count();
}
  6e:	e0 e1       	ldi	r30, 0x10	; 16
  70:	f8 e0       	ldi	r31, 0x08	; 8
  72:	83 e6       	ldi	r24, 0x63	; 99
  74:	86 83       	std	Z+6, r24	; 0x06
  76:	81 e5       	ldi	r24, 0x51	; 81
  78:	83 83       	std	Z+3, r24	; 0x03
  7a:	81 e0       	ldi	r24, 0x01	; 1
  7c:	85 83       	std	Z+5, r24	; 0x05
  7e:	88 ed       	ldi	r24, 0xD8	; 216
  80:	84 87       	std	Z+12, r24	; 0x0c
  82:	83 e8       	ldi	r24, 0x83	; 131
  84:	81 87       	std	Z+9, r24	; 0x09
  86:	08 95       	ret

00000088 <_Z17StartTransmissionv>:
  88:	80 91 47 3f 	lds	r24, 0x3F47	; 0x803f47 <isTransmitting>
  8c:	81 11       	cpse	r24, r1
  8e:	08 c0       	rjmp	.+16     	; 0xa0 <_Z17StartTransmissionv+0x18>
  90:	10 92 46 3f 	sts	0x3F46, r1	; 0x803f46 <addressDone>
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	80 93 47 3f 	sts	0x3F47, r24	; 0x803f47 <isTransmitting>
  9a:	88 ed       	ldi	r24, 0xD8	; 216
  9c:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <__TEXT_REGION_LENGTH__+0x700817>
  a0:	08 95       	ret

000000a2 <_Z15EndTransmissionv>:
  a2:	e0 e1       	ldi	r30, 0x10	; 16
  a4:	f8 e0       	ldi	r31, 0x08	; 8
  a6:	84 81       	ldd	r24, Z+4	; 0x04
  a8:	83 60       	ori	r24, 0x03	; 3
  aa:	84 83       	std	Z+4, r24	; 0x04
  ac:	10 92 47 3f 	sts	0x3F47, r1	; 0x803f47 <isTransmitting>
  b0:	08 95       	ret

000000b2 <_ZN10RingBufferILh16EE5CountEv>:
	}
}

//Returns how many elements are in the buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Count(){
  b2:	fc 01       	movw	r30, r24
	//Compensate for overflows
	if (head >= tail)
  b4:	81 89       	ldd	r24, Z+17	; 0x11
  b6:	22 89       	ldd	r18, Z+18	; 0x12
  b8:	82 17       	cp	r24, r18
  ba:	10 f0       	brcs	.+4      	; 0xc0 <_ZN10RingBufferILh16EE5CountEv+0xe>
	{
		return (head - tail);
  bc:	82 1b       	sub	r24, r18
  be:	08 95       	ret
	} else {
		return (head - tail + length);
  c0:	90 81       	ld	r25, Z
  c2:	89 0f       	add	r24, r25
  c4:	82 1b       	sub	r24, r18
	}
}
  c6:	08 95       	ret

000000c8 <_Z12WordCountI2Cv>:
  c8:	89 e4       	ldi	r24, 0x49	; 73
  ca:	9f e3       	ldi	r25, 0x3F	; 63
  cc:	f2 df       	rcall	.-28     	; 0xb2 <_ZN10RingBufferILh16EE5CountEv>
  ce:	08 95       	ret

000000d0 <_ZN10RingBufferILh32EE5CountEv>:
	}
}

//Returns how many elements are in the buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Count(){
  d0:	fc 01       	movw	r30, r24
	//Compensate for overflows
	if (head >= tail)
  d2:	81 a1       	ldd	r24, Z+33	; 0x21
  d4:	22 a1       	ldd	r18, Z+34	; 0x22
  d6:	82 17       	cp	r24, r18
  d8:	10 f0       	brcs	.+4      	; 0xde <_ZN10RingBufferILh32EE5CountEv+0xe>
	{
		return (head - tail);
  da:	82 1b       	sub	r24, r18
  dc:	08 95       	ret
	} else {
		return (head - tail + length);
  de:	90 81       	ld	r25, Z
  e0:	89 0f       	add	r24, r25
  e2:	82 1b       	sub	r24, r18
	}
}
  e4:	08 95       	ret

000000e6 <_ZN10RingBufferILh32EE4ReadEv>:
}
*/

//Read the next byte in buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Read(){
  e6:	cf 93       	push	r28
  e8:	df 93       	push	r29
  ea:	ec 01       	movw	r28, r24
	if (Count() > 0)
  ec:	f1 df       	rcall	.-30     	; 0xd0 <_ZN10RingBufferILh32EE5CountEv>
  ee:	88 23       	and	r24, r24
  f0:	59 f0       	breq	.+22     	; 0x108 <_ZN10RingBufferILh32EE4ReadEv+0x22>
	{
		tail++;
  f2:	8a a1       	ldd	r24, Y+34	; 0x22
  f4:	8f 5f       	subi	r24, 0xFF	; 255
  f6:	8a a3       	std	Y+34, r24	; 0x22
		if (tail >= length)
  f8:	98 81       	ld	r25, Y
  fa:	89 17       	cp	r24, r25
  fc:	08 f0       	brcs	.+2      	; 0x100 <_ZN10RingBufferILh32EE4ReadEv+0x1a>
		{
			tail = 0;
  fe:	1a a2       	std	Y+34, r1	; 0x22
		}
		return buffer[tail];
 100:	8a a1       	ldd	r24, Y+34	; 0x22
 102:	c8 0f       	add	r28, r24
 104:	d1 1d       	adc	r29, r1
 106:	89 81       	ldd	r24, Y+1	; 0x01
	}
	return 0;
}
 108:	df 91       	pop	r29
 10a:	cf 91       	pop	r28
 10c:	08 95       	ret

0000010e <_Z7SendI2Ch>:
 10e:	88 23       	and	r24, r24
 110:	71 f0       	breq	.+28     	; 0x12e <_Z7SendI2Ch+0x20>
 112:	80 91 48 3f 	lds	r24, 0x3F48	; 0x803f48 <currentWord>
 116:	81 11       	cpse	r24, r1
 118:	02 c0       	rjmp	.+4      	; 0x11e <_Z7SendI2Ch+0x10>
 11a:	c3 df       	rcall	.-122    	; 0xa2 <_Z15EndTransmissionv>
 11c:	08 95       	ret
 11e:	81 50       	subi	r24, 0x01	; 1
 120:	80 93 48 3f 	sts	0x3F48, r24	; 0x803f48 <currentWord>
 124:	80 e0       	ldi	r24, 0x00	; 0
 126:	9f e3       	ldi	r25, 0x3F	; 63
 128:	de df       	rcall	.-68     	; 0xe6 <_ZN10RingBufferILh32EE4ReadEv>
 12a:	80 93 5c 3f 	sts	0x3F5C, r24	; 0x803f5c <currentChar>
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	80 93 46 3f 	sts	0x3F46, r24	; 0x803f46 <addressDone>
 134:	80 91 5c 3f 	lds	r24, 0x3F5C	; 0x803f5c <currentChar>
 138:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <__TEXT_REGION_LENGTH__+0x700818>
 13c:	08 95       	ret

0000013e <__vector_20>:
 13e:	1f 92       	push	r1
 140:	0f 92       	push	r0
 142:	0f b6       	in	r0, 0x3f	; 63
 144:	0f 92       	push	r0
 146:	11 24       	eor	r1, r1
 148:	2f 93       	push	r18
 14a:	3f 93       	push	r19
 14c:	4f 93       	push	r20
 14e:	5f 93       	push	r21
 150:	6f 93       	push	r22
 152:	7f 93       	push	r23
 154:	8f 93       	push	r24
 156:	9f 93       	push	r25
 158:	af 93       	push	r26
 15a:	bf 93       	push	r27
 15c:	ef 93       	push	r30
 15e:	ff 93       	push	r31
 160:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 164:	83 ff       	sbrs	r24, 3
 166:	0c c0       	rjmp	.+24     	; 0x180 <__vector_20+0x42>
 168:	80 91 46 3f 	lds	r24, 0x3F46	; 0x803f46 <addressDone>
 16c:	88 23       	and	r24, r24
 16e:	11 f0       	breq	.+4      	; 0x174 <__vector_20+0x36>
 170:	80 e0       	ldi	r24, 0x00	; 0
 172:	cd df       	rcall	.-102    	; 0x10e <_Z7SendI2Ch>
 174:	e0 e1       	ldi	r30, 0x10	; 16
 176:	f8 e0       	ldi	r31, 0x08	; 8
 178:	85 81       	ldd	r24, Z+5	; 0x05
 17a:	88 60       	ori	r24, 0x08	; 8
 17c:	85 83       	std	Z+5, r24	; 0x05
 17e:	02 c0       	rjmp	.+4      	; 0x184 <__vector_20+0x46>
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	c5 df       	rcall	.-118    	; 0x10e <_Z7SendI2Ch>
 184:	ff 91       	pop	r31
 186:	ef 91       	pop	r30
 188:	bf 91       	pop	r27
 18a:	af 91       	pop	r26
 18c:	9f 91       	pop	r25
 18e:	8f 91       	pop	r24
 190:	7f 91       	pop	r23
 192:	6f 91       	pop	r22
 194:	5f 91       	pop	r21
 196:	4f 91       	pop	r20
 198:	3f 91       	pop	r19
 19a:	2f 91       	pop	r18
 19c:	0f 90       	pop	r0
 19e:	0f be       	out	0x3f, r0	; 63
 1a0:	0f 90       	pop	r0
 1a2:	1f 90       	pop	r1
 1a4:	18 95       	reti

000001a6 <_ZN10RingBufferILh32EE5WriteEh>:
	return buffer[tempTail];
}

//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
 1a6:	1f 93       	push	r17
 1a8:	cf 93       	push	r28
 1aa:	df 93       	push	r29
 1ac:	ec 01       	movw	r28, r24
 1ae:	16 2f       	mov	r17, r22
	if (Count() < length - 2)
 1b0:	8f df       	rcall	.-226    	; 0xd0 <_ZN10RingBufferILh32EE5CountEv>
 1b2:	48 81       	ld	r20, Y
 1b4:	90 e0       	ldi	r25, 0x00	; 0
 1b6:	24 2f       	mov	r18, r20
 1b8:	30 e0       	ldi	r19, 0x00	; 0
 1ba:	22 50       	subi	r18, 0x02	; 2
 1bc:	31 09       	sbc	r19, r1
 1be:	82 17       	cp	r24, r18
 1c0:	93 07       	cpc	r25, r19
 1c2:	5c f4       	brge	.+22     	; 0x1da <_ZN10RingBufferILh32EE5WriteEh+0x34>
	{
		head++;
 1c4:	89 a1       	ldd	r24, Y+33	; 0x21
 1c6:	8f 5f       	subi	r24, 0xFF	; 255
		
		if (head >= length)
 1c8:	84 17       	cp	r24, r20
 1ca:	10 f4       	brcc	.+4      	; 0x1d0 <_ZN10RingBufferILh32EE5WriteEh+0x2a>
//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
	{
		head++;
 1cc:	89 a3       	std	Y+33, r24	; 0x21
 1ce:	01 c0       	rjmp	.+2      	; 0x1d2 <_ZN10RingBufferILh32EE5WriteEh+0x2c>
		
		if (head >= length)
		{
			head = 0;
 1d0:	19 a2       	std	Y+33, r1	; 0x21
		}
		
		buffer[head] = in;
 1d2:	89 a1       	ldd	r24, Y+33	; 0x21
 1d4:	c8 0f       	add	r28, r24
 1d6:	d1 1d       	adc	r29, r1
 1d8:	19 83       	std	Y+1, r17	; 0x01
	}
}
 1da:	df 91       	pop	r29
 1dc:	cf 91       	pop	r28
 1de:	1f 91       	pop	r17
 1e0:	08 95       	ret

000001e2 <_Z5TXI2Ch>:
uint8_t WordCountI2C(){
	return wordLength.Count();
}

//Loads I2C byte into buffer
uint8_t TXI2C(uint8_t msg){
 1e2:	cf 93       	push	r28
 1e4:	c8 2f       	mov	r28, r24
	if (I2Cbuffer_TX.Count() > I2Cbuffer_TX.length)
 1e6:	80 e0       	ldi	r24, 0x00	; 0
 1e8:	9f e3       	ldi	r25, 0x3F	; 63
 1ea:	72 df       	rcall	.-284    	; 0xd0 <_ZN10RingBufferILh32EE5CountEv>
 1ec:	90 91 00 3f 	lds	r25, 0x3F00	; 0x803f00 <_edata>
 1f0:	98 17       	cp	r25, r24
 1f2:	30 f0       	brcs	.+12     	; 0x200 <_Z5TXI2Ch+0x1e>
	{
		return 1;
	}
	I2Cbuffer_TX.Write(msg);
 1f4:	6c 2f       	mov	r22, r28
 1f6:	80 e0       	ldi	r24, 0x00	; 0
 1f8:	9f e3       	ldi	r25, 0x3F	; 63
 1fa:	d5 df       	rcall	.-86     	; 0x1a6 <_ZN10RingBufferILh32EE5WriteEh>
	return 0;
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	01 c0       	rjmp	.+2      	; 0x202 <_Z5TXI2Ch+0x20>

//Loads I2C byte into buffer
uint8_t TXI2C(uint8_t msg){
	if (I2Cbuffer_TX.Count() > I2Cbuffer_TX.length)
	{
		return 1;
 200:	81 e0       	ldi	r24, 0x01	; 1
	}
	I2Cbuffer_TX.Write(msg);
	return 0;
}
 202:	cf 91       	pop	r28
 204:	08 95       	ret

00000206 <__vector_19>:

//Slave interrupt
ISR(TWI0_TWIS_vect){
 206:	1f 92       	push	r1
 208:	0f 92       	push	r0
 20a:	0f b6       	in	r0, 0x3f	; 63
 20c:	0f 92       	push	r0
 20e:	11 24       	eor	r1, r1
 210:	2f 93       	push	r18
 212:	3f 93       	push	r19
 214:	4f 93       	push	r20
 216:	5f 93       	push	r21
 218:	6f 93       	push	r22
 21a:	7f 93       	push	r23
 21c:	8f 93       	push	r24
 21e:	9f 93       	push	r25
 220:	af 93       	push	r26
 222:	bf 93       	push	r27
 224:	cf 93       	push	r28
 226:	df 93       	push	r29
 228:	ef 93       	push	r30
 22a:	ff 93       	push	r31
	I2Cbuffer_RX.Write(TWI0.SDATA);
 22c:	c0 e1       	ldi	r28, 0x10	; 16
 22e:	d8 e0       	ldi	r29, 0x08	; 8
 230:	6d 85       	ldd	r22, Y+13	; 0x0d
 232:	83 e2       	ldi	r24, 0x23	; 35
 234:	9f e3       	ldi	r25, 0x3F	; 63
 236:	b7 df       	rcall	.-146    	; 0x1a6 <_ZN10RingBufferILh32EE5WriteEh>
	TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
 238:	83 e0       	ldi	r24, 0x03	; 3
 23a:	8a 87       	std	Y+10, r24	; 0x0a
}
 23c:	ff 91       	pop	r31
 23e:	ef 91       	pop	r30
 240:	df 91       	pop	r29
 242:	cf 91       	pop	r28
 244:	bf 91       	pop	r27
 246:	af 91       	pop	r26
 248:	9f 91       	pop	r25
 24a:	8f 91       	pop	r24
 24c:	7f 91       	pop	r23
 24e:	6f 91       	pop	r22
 250:	5f 91       	pop	r21
 252:	4f 91       	pop	r20
 254:	3f 91       	pop	r19
 256:	2f 91       	pop	r18
 258:	0f 90       	pop	r0
 25a:	0f be       	out	0x3f, r0	; 63
 25c:	0f 90       	pop	r0
 25e:	1f 90       	pop	r1
 260:	18 95       	reti

00000262 <_GLOBAL__sub_I_currentChar>:

#ifndef RINGBUFFER_H_
#define RINGBUFFER_H_

template <uint8_t BUFFER_SIZE>
class RingBuffer
 262:	e9 e4       	ldi	r30, 0x49	; 73
 264:	ff e3       	ldi	r31, 0x3F	; 63
 266:	80 e1       	ldi	r24, 0x10	; 16
 268:	80 83       	st	Z, r24
 26a:	11 8a       	std	Z+17, r1	; 0x11
 26c:	12 8a       	std	Z+18, r1	; 0x12
 26e:	e3 e2       	ldi	r30, 0x23	; 35
 270:	ff e3       	ldi	r31, 0x3F	; 63
 272:	80 e2       	ldi	r24, 0x20	; 32
 274:	80 83       	st	Z, r24
 276:	11 a2       	std	Z+33, r1	; 0x21
 278:	12 a2       	std	Z+34, r1	; 0x22
 27a:	e0 e0       	ldi	r30, 0x00	; 0
 27c:	ff e3       	ldi	r31, 0x3F	; 63
 27e:	80 83       	st	Z, r24
 280:	11 a2       	std	Z+33, r1	; 0x21
 282:	12 a2       	std	Z+34, r1	; 0x22
 284:	08 95       	ret

00000286 <_Z8Led_Initv>:
	TCB0.CTRLA |= TCB_ENABLE_bm;
}

void I2C_Activity(){
	PORTA.OUTSET = PIN7_bm;
	TCB0.CTRLA |= TCB_ENABLE_bm;
 286:	e0 e4       	ldi	r30, 0x40	; 64
 288:	fa e0       	ldi	r31, 0x0A	; 10
 28a:	82 e0       	ldi	r24, 0x02	; 2
 28c:	80 83       	st	Z, r24
 28e:	81 e0       	ldi	r24, 0x01	; 1
 290:	85 83       	std	Z+5, r24	; 0x05
 292:	11 82       	std	Z+1, r1	; 0x01
 294:	80 ea       	ldi	r24, 0xA0	; 160
 296:	9f e0       	ldi	r25, 0x0F	; 15
 298:	84 87       	std	Z+12, r24	; 0x0c
 29a:	95 87       	std	Z+13, r25	; 0x0d
 29c:	80 81       	ld	r24, Z
 29e:	81 60       	ori	r24, 0x01	; 1
 2a0:	80 83       	st	Z, r24
 2a2:	e0 e0       	ldi	r30, 0x00	; 0
 2a4:	f4 e0       	ldi	r31, 0x04	; 4
 2a6:	80 e8       	ldi	r24, 0x80	; 128
 2a8:	81 83       	std	Z+1, r24	; 0x01
 2aa:	a0 e2       	ldi	r26, 0x20	; 32
 2ac:	b4 e0       	ldi	r27, 0x04	; 4
 2ae:	90 e1       	ldi	r25, 0x10	; 16
 2b0:	11 96       	adiw	r26, 0x01	; 1
 2b2:	9c 93       	st	X, r25
 2b4:	11 97       	sbiw	r26, 0x01	; 1
 2b6:	15 96       	adiw	r26, 0x05	; 5
 2b8:	9c 93       	st	X, r25
 2ba:	85 83       	std	Z+5, r24	; 0x05
 2bc:	08 95       	ret

000002be <__vector_13>:
}

ISR(TCB0_INT_vect){
 2be:	1f 92       	push	r1
 2c0:	0f 92       	push	r0
 2c2:	0f b6       	in	r0, 0x3f	; 63
 2c4:	0f 92       	push	r0
 2c6:	11 24       	eor	r1, r1
 2c8:	8f 93       	push	r24
 2ca:	ef 93       	push	r30
 2cc:	ff 93       	push	r31
	//Clear flag
	TCB0.INTFLAGS = TCB_CAPT_bm;
 2ce:	e0 e4       	ldi	r30, 0x40	; 64
 2d0:	fa e0       	ldi	r31, 0x0A	; 10
 2d2:	81 e0       	ldi	r24, 0x01	; 1
 2d4:	86 83       	std	Z+6, r24	; 0x06
	
	//Disable timer
	TCB0.CTRLA &= ~(TCB_ENABLE_bm);
 2d6:	80 81       	ld	r24, Z
 2d8:	8e 7f       	andi	r24, 0xFE	; 254
 2da:	80 83       	st	Z, r24
	
	//Turn off leds
	PORTA.OUTCLR = PIN7_bm;
 2dc:	80 e8       	ldi	r24, 0x80	; 128
 2de:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__TEXT_REGION_LENGTH__+0x700406>
	PORTB.OUTCLR = PIN4_bm;
 2e2:	80 e1       	ldi	r24, 0x10	; 16
 2e4:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <__TEXT_REGION_LENGTH__+0x700426>
 2e8:	ff 91       	pop	r31
 2ea:	ef 91       	pop	r30
 2ec:	8f 91       	pop	r24
 2ee:	0f 90       	pop	r0
 2f0:	0f be       	out	0x3f, r0	; 63
 2f2:	0f 90       	pop	r0
 2f4:	1f 90       	pop	r1
 2f6:	18 95       	reti

000002f8 <_Z8CLK_Initv>:
    }
}

void CLK_Init(){
	//Disable prescaler
	CCP = CCP_IOREG_gc;
 2f8:	88 ed       	ldi	r24, 0xD8	; 216
 2fa:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB &= ~CLKCTRL_PEN_bm;
 2fc:	e0 e6       	ldi	r30, 0x60	; 96
 2fe:	f0 e0       	ldi	r31, 0x00	; 0
 300:	81 81       	ldd	r24, Z+1	; 0x01
 302:	8e 7f       	andi	r24, 0xFE	; 254
 304:	81 83       	std	Z+1, r24	; 0x01
 306:	08 95       	ret

00000308 <_Z10Timer_Initv>:
}

void Timer_Init(){
	//Set normal mode.
	TCA0.SINGLE.CTRLB = TCA_SINGLE_WGMODE_NORMAL_gc;
 308:	e0 e0       	ldi	r30, 0x00	; 0
 30a:	fa e0       	ldi	r31, 0x0A	; 10
 30c:	11 82       	std	Z+1, r1	; 0x01
	
	//Set timer period = 1ms
	TCA0.SINGLE.PER = 1250;
 30e:	82 ee       	ldi	r24, 0xE2	; 226
 310:	94 e0       	ldi	r25, 0x04	; 4
 312:	86 a3       	std	Z+38, r24	; 0x26
 314:	97 a3       	std	Z+39, r25	; 0x27
	
	//Enable interrupt
	TCA0.SINGLE.INTCTRL = TCA_SINGLE_OVF_bm;
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	82 87       	std	Z+10, r24	; 0x0a
	
	//Enable timer
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc|TCA_SINGLE_ENABLE_bm;
 31a:	89 e0       	ldi	r24, 0x09	; 9
 31c:	80 83       	st	Z, r24
 31e:	08 95       	ret

00000320 <__vector_8>:
			status.dinDone = 1;
		}
	}
}

ISR(TCA0_OVF_vect){
 320:	1f 92       	push	r1
 322:	0f 92       	push	r0
 324:	0f b6       	in	r0, 0x3f	; 63
 326:	0f 92       	push	r0
 328:	11 24       	eor	r1, r1
 32a:	8f 93       	push	r24
	//Byte timeout, switch source
	if (status.currentSource == DIN5)
 32c:	80 91 5f 3f 	lds	r24, 0x3F5F	; 0x803f5f <status+0x1>
 330:	81 11       	cpse	r24, r1
 332:	04 c0       	rjmp	.+8      	; 0x33c <__vector_8+0x1c>
	{
		status.currentSource = I2C;
 334:	81 e0       	ldi	r24, 0x01	; 1
 336:	80 93 5f 3f 	sts	0x3F5F, r24	; 0x803f5f <status+0x1>
 33a:	02 c0       	rjmp	.+4      	; 0x340 <__vector_8+0x20>
	} 
	else
	{
		status.currentSource = DIN5;
 33c:	10 92 5f 3f 	sts	0x3F5F, r1	; 0x803f5f <status+0x1>
	}
}
 340:	8f 91       	pop	r24
 342:	0f 90       	pop	r0
 344:	0f be       	out	0x3f, r0	; 63
 346:	0f 90       	pop	r0
 348:	1f 90       	pop	r1
 34a:	18 95       	reti

0000034c <_Z5Mergev>:
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc|TCA_SINGLE_ENABLE_bm;
}


void Merge(){
	if (status.dinDone && status.I2CDone) {
 34c:	80 91 60 3f 	lds	r24, 0x3F60	; 0x803f60 <status+0x2>
 350:	88 23       	and	r24, r24
 352:	09 f4       	brne	.+2      	; 0x356 <_Z5Mergev+0xa>
 354:	62 c0       	rjmp	.+196    	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
 356:	80 91 61 3f 	lds	r24, 0x3F61	; 0x803f61 <status+0x3>
 35a:	88 23       	and	r24, r24
 35c:	09 f4       	brne	.+2      	; 0x360 <_Z5Mergev+0x14>
 35e:	61 c0       	rjmp	.+194    	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
		//Get character
		if (status.currentSource == DIN5)
 360:	80 91 5f 3f 	lds	r24, 0x3F5F	; 0x803f5f <status+0x1>
 364:	81 11       	cpse	r24, r1
 366:	33 c0       	rjmp	.+102    	; 0x3ce <_Z5Mergev+0x82>
		{
			if (bufferUART_RX.Count() > 0)
 368:	86 e7       	ldi	r24, 0x76	; 118
 36a:	9f e3       	ldi	r25, 0x3F	; 63
 36c:	b1 de       	rcall	.-670    	; 0xd0 <_ZN10RingBufferILh32EE5CountEv>
 36e:	88 23       	and	r24, r24
 370:	09 f4       	brne	.+2      	; 0x374 <_Z5Mergev+0x28>
 372:	68 c0       	rjmp	.+208    	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
			{
				status.currentChar = bufferUART_RX.Read();	
 374:	86 e7       	ldi	r24, 0x76	; 118
 376:	9f e3       	ldi	r25, 0x3F	; 63
 378:	b6 de       	rcall	.-660    	; 0xe6 <_ZN10RingBufferILh32EE4ReadEv>
 37a:	80 93 5e 3f 	sts	0x3F5E, r24	; 0x803f5e <status>
				//reset timer
				TCA0.SINGLE.CNT = 0;
 37e:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
 382:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
}

//Read next byte without incrementing pointers
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Peek(){
	uint8_t tempTail = tail + 1;
 386:	a6 e7       	ldi	r26, 0x76	; 118
 388:	bf e3       	ldi	r27, 0x3F	; 63
 38a:	92 96       	adiw	r26, 0x22	; 34
 38c:	ec 91       	ld	r30, X
 38e:	92 97       	sbiw	r26, 0x22	; 34
 390:	ef 5f       	subi	r30, 0xFF	; 255
	
	if (tempTail >= length)
 392:	9c 91       	ld	r25, X
 394:	e9 17       	cp	r30, r25
 396:	08 f0       	brcs	.+2      	; 0x39a <_Z5Mergev+0x4e>
	{
		tempTail = 0;
 398:	e0 e0       	ldi	r30, 0x00	; 0
	}
	
	return buffer[tempTail];
 39a:	f0 e0       	ldi	r31, 0x00	; 0
 39c:	ea 58       	subi	r30, 0x8A	; 138
 39e:	f0 4c       	sbci	r31, 0xC0	; 192
			} else {
				//No data
				return;
			}
			
			if (bufferUART_RX.Peek() > 127)
 3a0:	91 81       	ldd	r25, Z+1	; 0x01
 3a2:	99 23       	and	r25, r25
 3a4:	1c f4       	brge	.+6      	; 0x3ac <_Z5Mergev+0x60>
			{
				//Next char is command byte
				status.currentSource = I2C;
 3a6:	91 e0       	ldi	r25, 0x01	; 1
 3a8:	90 93 5f 3f 	sts	0x3F5F, r25	; 0x803f5f <status+0x1>
			}
			
			//Try to load character
			if (TXI2C(status.currentChar))
 3ac:	1a df       	rcall	.-460    	; 0x1e2 <_Z5TXI2Ch>
 3ae:	81 11       	cpse	r24, r1
			{
				//I2C failed
				status.I2CDone = 0;
 3b0:	10 92 61 3f 	sts	0x3F61, r1	; 0x803f61 <status+0x3>
			}
			
			if (thruUART)
 3b4:	80 91 5d 3f 	lds	r24, 0x3F5D	; 0x803f5d <thruUART>
 3b8:	88 23       	and	r24, r24
 3ba:	09 f4       	brne	.+2      	; 0x3be <_Z5Mergev+0x72>
 3bc:	43 c0       	rjmp	.+134    	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
			{
				if (UART_TX(status.currentChar))
 3be:	80 91 5e 3f 	lds	r24, 0x3F5E	; 0x803f5e <status>
 3c2:	ae d0       	rcall	.+348    	; 0x520 <_Z7UART_TXh>
 3c4:	88 23       	and	r24, r24
 3c6:	f1 f1       	breq	.+124    	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
				{
					//Uart failed
					status.dinDone = 0;
 3c8:	10 92 60 3f 	sts	0x3F60, r1	; 0x803f60 <status+0x2>
 3cc:	08 95       	ret
				}
			}
			
			
		} else {
			if (I2Cbuffer_RX.Count() > 0)
 3ce:	83 e2       	ldi	r24, 0x23	; 35
 3d0:	9f e3       	ldi	r25, 0x3F	; 63
 3d2:	7e de       	rcall	.-772    	; 0xd0 <_ZN10RingBufferILh32EE5CountEv>
 3d4:	88 23       	and	r24, r24
 3d6:	b1 f1       	breq	.+108    	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
			{
				status.currentChar = I2Cbuffer_RX.Read();
 3d8:	83 e2       	ldi	r24, 0x23	; 35
 3da:	9f e3       	ldi	r25, 0x3F	; 63
 3dc:	84 de       	rcall	.-760    	; 0xe6 <_ZN10RingBufferILh32EE4ReadEv>
 3de:	80 93 5e 3f 	sts	0x3F5E, r24	; 0x803f5e <status>
				//reset timer
				TCA0.SINGLE.CNT = 0;
 3e2:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
 3e6:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
}

//Read next byte without incrementing pointers
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Peek(){
	uint8_t tempTail = tail + 1;
 3ea:	a3 e2       	ldi	r26, 0x23	; 35
 3ec:	bf e3       	ldi	r27, 0x3F	; 63
 3ee:	92 96       	adiw	r26, 0x22	; 34
 3f0:	ec 91       	ld	r30, X
 3f2:	92 97       	sbiw	r26, 0x22	; 34
 3f4:	ef 5f       	subi	r30, 0xFF	; 255
	
	if (tempTail >= length)
 3f6:	9c 91       	ld	r25, X
 3f8:	e9 17       	cp	r30, r25
 3fa:	08 f0       	brcs	.+2      	; 0x3fe <_Z5Mergev+0xb2>
	{
		tempTail = 0;
 3fc:	e0 e0       	ldi	r30, 0x00	; 0
	}
	
	return buffer[tempTail];
 3fe:	f0 e0       	ldi	r31, 0x00	; 0
 400:	ed 5d       	subi	r30, 0xDD	; 221
 402:	f0 4c       	sbci	r31, 0xC0	; 192
			} else {
				//No data
				return;
			}
			
			if (I2Cbuffer_RX.Peek() > 127)
 404:	91 81       	ldd	r25, Z+1	; 0x01
 406:	99 23       	and	r25, r25
 408:	14 f4       	brge	.+4      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
			{
				//Next char is command byte
				status.currentSource = DIN5;
 40a:	10 92 5f 3f 	sts	0x3F5F, r1	; 0x803f5f <status+0x1>
			}
			
			//Try to load character
			if (UART_TX(status.currentChar))
 40e:	88 d0       	rcall	.+272    	; 0x520 <_Z7UART_TXh>
 410:	88 23       	and	r24, r24
 412:	c1 f0       	breq	.+48     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
			{
				//Uart failed
				status.dinDone = 0;
 414:	10 92 60 3f 	sts	0x3F60, r1	; 0x803f60 <status+0x2>
 418:	08 95       	ret
			}
		}
			
	} else if (!status.I2CDone) {
 41a:	80 91 61 3f 	lds	r24, 0x3F61	; 0x803f61 <status+0x3>
 41e:	81 11       	cpse	r24, r1
 420:	09 c0       	rjmp	.+18     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
		if (!TXI2C(status.currentChar))
 422:	80 91 5e 3f 	lds	r24, 0x3F5E	; 0x803f5e <status>
 426:	dd de       	rcall	.-582    	; 0x1e2 <_Z5TXI2Ch>
 428:	81 11       	cpse	r24, r1
 42a:	0c c0       	rjmp	.+24     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
		{
			status.I2CDone = 1;
 42c:	81 e0       	ldi	r24, 0x01	; 1
 42e:	80 93 61 3f 	sts	0x3F61, r24	; 0x803f61 <status+0x3>
 432:	08 95       	ret
		}
	} else {
		if (!UART_TX(status.currentChar))
 434:	80 91 5e 3f 	lds	r24, 0x3F5E	; 0x803f5e <status>
 438:	73 d0       	rcall	.+230    	; 0x520 <_Z7UART_TXh>
 43a:	81 11       	cpse	r24, r1
 43c:	03 c0       	rjmp	.+6      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
		{
			status.dinDone = 1;
 43e:	81 e0       	ldi	r24, 0x01	; 1
 440:	80 93 60 3f 	sts	0x3F60, r24	; 0x803f60 <status+0x2>
 444:	08 95       	ret

00000446 <main>:
struct MergeStatus status;
bool thruUART = false;

int main(void)
{
	CLK_Init();
 446:	58 df       	rcall	.-336    	; 0x2f8 <_Z8CLK_Initv>
	Timer_Init();
 448:	5f df       	rcall	.-322    	; 0x308 <_Z10Timer_Initv>
	UART_Init();
 44a:	1c d0       	rcall	.+56     	; 0x484 <_Z9UART_Initv>
	I2C_Init();
 44c:	10 de       	rcall	.-992    	; 0x6e <_Z8I2C_Initv>
	Led_Init();
 44e:	1b df       	rcall	.-458    	; 0x286 <_Z8Led_Initv>
	
	//Set button pullup
	//PORTB.PIN2CTRL = PORT_PULLUPEN_bm;
	
	//Set LEDS as output
	PORTB.DIRSET = PIN4_bm;
 450:	80 e1       	ldi	r24, 0x10	; 16
 452:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <__TEXT_REGION_LENGTH__+0x700421>
	PORTA.DIRSET = PIN7_bm;
 456:	80 e8       	ldi	r24, 0x80	; 128
 458:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <__TEXT_REGION_LENGTH__+0x700401>
	
	status.currentSource = DIN5;
 45c:	ee e5       	ldi	r30, 0x5E	; 94
 45e:	ff e3       	ldi	r31, 0x3F	; 63
 460:	11 82       	std	Z+1, r1	; 0x01
	status.dinDone = 1;
 462:	81 e0       	ldi	r24, 0x01	; 1
 464:	82 83       	std	Z+2, r24	; 0x02
	status.I2CDone = 1;
 466:	83 83       	std	Z+3, r24	; 0x03
	
	
    while (1) 
    {
		thruUART = PORTB.IN & PIN2_bm;	//Insert button here
 468:	c0 e2       	ldi	r28, 0x20	; 32
 46a:	d4 e0       	ldi	r29, 0x04	; 4
 46c:	88 85       	ldd	r24, Y+8	; 0x08
 46e:	82 fb       	bst	r24, 2
 470:	88 27       	eor	r24, r24
 472:	80 f9       	bld	r24, 0
 474:	80 93 5d 3f 	sts	0x3F5D, r24	; 0x803f5d <thruUART>
		Merge();
 478:	69 df       	rcall	.-302    	; 0x34c <_Z5Mergev>
		
		if (WordCountI2C() > 0)
 47a:	26 de       	rcall	.-948    	; 0xc8 <_Z12WordCountI2Cv>
 47c:	88 23       	and	r24, r24
 47e:	b1 f3       	breq	.-20     	; 0x46c <main+0x26>
		{
			StartTransmission();
 480:	03 de       	rcall	.-1018   	; 0x88 <_Z17StartTransmissionv>
 482:	f4 cf       	rjmp	.-24     	; 0x46c <main+0x26>

00000484 <_Z9UART_Initv>:

#define MIDIRate (64*F_CPU/31250)

void UART_Init(){
	//Set Baudrate = 31250Hz
	USART0.BAUD = MIDIRate;
 484:	e0 e0       	ldi	r30, 0x00	; 0
 486:	f8 e0       	ldi	r31, 0x08	; 8
 488:	80 e0       	ldi	r24, 0x00	; 0
 48a:	90 ea       	ldi	r25, 0xA0	; 160
 48c:	80 87       	std	Z+8, r24	; 0x08
 48e:	91 87       	std	Z+9, r25	; 0x09
	
	//Enable RX interrupt
	USART0.CTRLA = USART_RXCIE_bm;
 490:	80 e8       	ldi	r24, 0x80	; 128
 492:	85 83       	std	Z+5, r24	; 0x05
	
	//Set frame format: 8bit, 1stop
	//USART0.CTRLC = USART_CHSIZE_8BIT_gc;
	
	//Enable RX and TX
	USART0.CTRLB = USART_RXEN_bm|USART_TXEN_bm;
 494:	80 ec       	ldi	r24, 0xC0	; 192
 496:	86 83       	std	Z+6, r24	; 0x06
 498:	08 95       	ret

0000049a <__vector_22>:
	//Enable interrupt
	USART0.CTRLA |= USART_DREIE_bm;
	return 0;
}

ISR(USART0_RXC_vect){
 49a:	1f 92       	push	r1
 49c:	0f 92       	push	r0
 49e:	0f b6       	in	r0, 0x3f	; 63
 4a0:	0f 92       	push	r0
 4a2:	11 24       	eor	r1, r1
 4a4:	2f 93       	push	r18
 4a6:	3f 93       	push	r19
 4a8:	4f 93       	push	r20
 4aa:	5f 93       	push	r21
 4ac:	6f 93       	push	r22
 4ae:	8f 93       	push	r24
 4b0:	9f 93       	push	r25
 4b2:	ef 93       	push	r30
 4b4:	ff 93       	push	r31
	uint8_t rx = USART0.RXDATAL;
 4b6:	60 91 00 08 	lds	r22, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>

//Returns how many elements are in the buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Count(){
	//Compensate for overflows
	if (head >= tail)
 4ba:	e6 e7       	ldi	r30, 0x76	; 118
 4bc:	ff e3       	ldi	r31, 0x3F	; 63
 4be:	21 a1       	ldd	r18, Z+33	; 0x21
 4c0:	92 a1       	ldd	r25, Z+34	; 0x22
 4c2:	29 17       	cp	r18, r25
 4c4:	18 f0       	brcs	.+6      	; 0x4cc <__vector_22+0x32>
	{
		return (head - tail);
 4c6:	82 2f       	mov	r24, r18
 4c8:	89 1b       	sub	r24, r25
 4ca:	04 c0       	rjmp	.+8      	; 0x4d4 <__vector_22+0x3a>
	} else {
		return (head - tail + length);
 4cc:	80 91 76 3f 	lds	r24, 0x3F76	; 0x803f76 <bufferUART_RX>
 4d0:	82 0f       	add	r24, r18
 4d2:	89 1b       	sub	r24, r25
}

//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
 4d4:	30 91 76 3f 	lds	r19, 0x3F76	; 0x803f76 <bufferUART_RX>
 4d8:	90 e0       	ldi	r25, 0x00	; 0
 4da:	43 2f       	mov	r20, r19
 4dc:	50 e0       	ldi	r21, 0x00	; 0
 4de:	42 50       	subi	r20, 0x02	; 2
 4e0:	51 09       	sbc	r21, r1
 4e2:	84 17       	cp	r24, r20
 4e4:	95 07       	cpc	r25, r21
 4e6:	74 f4       	brge	.+28     	; 0x504 <__vector_22+0x6a>
	{
		head++;
 4e8:	2f 5f       	subi	r18, 0xFF	; 255
		
		if (head >= length)
 4ea:	23 17       	cp	r18, r19
 4ec:	18 f4       	brcc	.+6      	; 0x4f4 <__vector_22+0x5a>
//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
	{
		head++;
 4ee:	20 93 97 3f 	sts	0x3F97, r18	; 0x803f97 <bufferUART_RX+0x21>
 4f2:	02 c0       	rjmp	.+4      	; 0x4f8 <__vector_22+0x5e>
		
		if (head >= length)
		{
			head = 0;
 4f4:	10 92 97 3f 	sts	0x3F97, r1	; 0x803f97 <bufferUART_RX+0x21>
		}
		
		buffer[head] = in;
 4f8:	e0 91 97 3f 	lds	r30, 0x3F97	; 0x803f97 <bufferUART_RX+0x21>
 4fc:	f0 e0       	ldi	r31, 0x00	; 0
 4fe:	ea 58       	subi	r30, 0x8A	; 138
 500:	f0 4c       	sbci	r31, 0xC0	; 192
 502:	61 83       	std	Z+1, r22	; 0x01
	bufferUART_RX.Write(rx);
}
 504:	ff 91       	pop	r31
 506:	ef 91       	pop	r30
 508:	9f 91       	pop	r25
 50a:	8f 91       	pop	r24
 50c:	6f 91       	pop	r22
 50e:	5f 91       	pop	r21
 510:	4f 91       	pop	r20
 512:	3f 91       	pop	r19
 514:	2f 91       	pop	r18
 516:	0f 90       	pop	r0
 518:	0f be       	out	0x3f, r0	; 63
 51a:	0f 90       	pop	r0
 51c:	1f 90       	pop	r1
 51e:	18 95       	reti

00000520 <_Z7UART_TXh>:
	
	//Enable RX and TX
	USART0.CTRLB = USART_RXEN_bm|USART_TXEN_bm;
}

uint8_t UART_TX(uint8_t msg){
 520:	cf 93       	push	r28
 522:	c8 2f       	mov	r28, r24
	if (bufferUART_TX.Count() > 254)
 524:	83 e6       	ldi	r24, 0x63	; 99
 526:	9f e3       	ldi	r25, 0x3F	; 63
 528:	c4 dd       	rcall	.-1144   	; 0xb2 <_ZN10RingBufferILh16EE5CountEv>
 52a:	8f 3f       	cpi	r24, 0xFF	; 255
 52c:	09 f1       	breq	.+66     	; 0x570 <_Z7UART_TXh+0x50>
}

//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
 52e:	40 91 63 3f 	lds	r20, 0x3F63	; 0x803f63 <bufferUART_TX>
 532:	90 e0       	ldi	r25, 0x00	; 0
 534:	24 2f       	mov	r18, r20
 536:	30 e0       	ldi	r19, 0x00	; 0
 538:	22 50       	subi	r18, 0x02	; 2
 53a:	31 09       	sbc	r19, r1
 53c:	82 17       	cp	r24, r18
 53e:	93 07       	cpc	r25, r19
 540:	84 f4       	brge	.+32     	; 0x562 <_Z7UART_TXh+0x42>
	{
		head++;
 542:	80 91 74 3f 	lds	r24, 0x3F74	; 0x803f74 <bufferUART_TX+0x11>
 546:	8f 5f       	subi	r24, 0xFF	; 255
		
		if (head >= length)
 548:	84 17       	cp	r24, r20
 54a:	18 f4       	brcc	.+6      	; 0x552 <_Z7UART_TXh+0x32>
//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
	{
		head++;
 54c:	80 93 74 3f 	sts	0x3F74, r24	; 0x803f74 <bufferUART_TX+0x11>
 550:	02 c0       	rjmp	.+4      	; 0x556 <_Z7UART_TXh+0x36>
		
		if (head >= length)
		{
			head = 0;
 552:	10 92 74 3f 	sts	0x3F74, r1	; 0x803f74 <bufferUART_TX+0x11>
		}
		
		buffer[head] = in;
 556:	e0 91 74 3f 	lds	r30, 0x3F74	; 0x803f74 <bufferUART_TX+0x11>
 55a:	f0 e0       	ldi	r31, 0x00	; 0
 55c:	ed 59       	subi	r30, 0x9D	; 157
 55e:	f0 4c       	sbci	r31, 0xC0	; 192
 560:	c1 83       	std	Z+1, r28	; 0x01
		return 1;
	}
	bufferUART_TX.Write(msg);
	
	//Enable interrupt
	USART0.CTRLA |= USART_DREIE_bm;
 562:	e0 e0       	ldi	r30, 0x00	; 0
 564:	f8 e0       	ldi	r31, 0x08	; 8
 566:	85 81       	ldd	r24, Z+5	; 0x05
 568:	80 62       	ori	r24, 0x20	; 32
 56a:	85 83       	std	Z+5, r24	; 0x05
	return 0;
 56c:	80 e0       	ldi	r24, 0x00	; 0
 56e:	01 c0       	rjmp	.+2      	; 0x572 <_Z7UART_TXh+0x52>
}

uint8_t UART_TX(uint8_t msg){
	if (bufferUART_TX.Count() > 254)
	{
		return 1;
 570:	81 e0       	ldi	r24, 0x01	; 1
	bufferUART_TX.Write(msg);
	
	//Enable interrupt
	USART0.CTRLA |= USART_DREIE_bm;
	return 0;
}
 572:	cf 91       	pop	r28
 574:	08 95       	ret

00000576 <__vector_23>:
ISR(USART0_RXC_vect){
	uint8_t rx = USART0.RXDATAL;
	bufferUART_RX.Write(rx);
}

ISR(USART0_DRE_vect){
 576:	1f 92       	push	r1
 578:	0f 92       	push	r0
 57a:	0f b6       	in	r0, 0x3f	; 63
 57c:	0f 92       	push	r0
 57e:	11 24       	eor	r1, r1
 580:	2f 93       	push	r18
 582:	3f 93       	push	r19
 584:	4f 93       	push	r20
 586:	5f 93       	push	r21
 588:	6f 93       	push	r22
 58a:	7f 93       	push	r23
 58c:	8f 93       	push	r24
 58e:	9f 93       	push	r25
 590:	af 93       	push	r26
 592:	bf 93       	push	r27
 594:	ef 93       	push	r30
 596:	ff 93       	push	r31
	if (bufferUART_TX.Count() > 0)
 598:	83 e6       	ldi	r24, 0x63	; 99
 59a:	9f e3       	ldi	r25, 0x3F	; 63
 59c:	8a dd       	rcall	.-1260   	; 0xb2 <_ZN10RingBufferILh16EE5CountEv>
 59e:	88 23       	and	r24, r24
 5a0:	99 f0       	breq	.+38     	; 0x5c8 <__vector_23+0x52>
//Read the next byte in buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Read(){
	if (Count() > 0)
	{
		tail++;
 5a2:	e3 e6       	ldi	r30, 0x63	; 99
 5a4:	ff e3       	ldi	r31, 0x3F	; 63
 5a6:	82 89       	ldd	r24, Z+18	; 0x12
 5a8:	8f 5f       	subi	r24, 0xFF	; 255
 5aa:	82 8b       	std	Z+18, r24	; 0x12
		if (tail >= length)
 5ac:	90 81       	ld	r25, Z
 5ae:	89 17       	cp	r24, r25
 5b0:	10 f0       	brcs	.+4      	; 0x5b6 <__vector_23+0x40>
		{
			tail = 0;
 5b2:	10 92 75 3f 	sts	0x3F75, r1	; 0x803f75 <bufferUART_TX+0x12>
		}
		return buffer[tail];
 5b6:	e0 91 75 3f 	lds	r30, 0x3F75	; 0x803f75 <bufferUART_TX+0x12>
 5ba:	f0 e0       	ldi	r31, 0x00	; 0
 5bc:	ed 59       	subi	r30, 0x9D	; 157
 5be:	f0 4c       	sbci	r31, 0xC0	; 192
 5c0:	81 81       	ldd	r24, Z+1	; 0x01
	{
		USART0.TXDATAL = bufferUART_TX.Read();
 5c2:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
 5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <__vector_23+0x5c>
	} else {
		//Disable interrupt if send register is empty
		USART0.CTRLA &= ~(USART_DREIE_bm);
 5c8:	e0 e0       	ldi	r30, 0x00	; 0
 5ca:	f8 e0       	ldi	r31, 0x08	; 8
 5cc:	85 81       	ldd	r24, Z+5	; 0x05
 5ce:	8f 7d       	andi	r24, 0xDF	; 223
 5d0:	85 83       	std	Z+5, r24	; 0x05
	}
}
 5d2:	ff 91       	pop	r31
 5d4:	ef 91       	pop	r30
 5d6:	bf 91       	pop	r27
 5d8:	af 91       	pop	r26
 5da:	9f 91       	pop	r25
 5dc:	8f 91       	pop	r24
 5de:	7f 91       	pop	r23
 5e0:	6f 91       	pop	r22
 5e2:	5f 91       	pop	r21
 5e4:	4f 91       	pop	r20
 5e6:	3f 91       	pop	r19
 5e8:	2f 91       	pop	r18
 5ea:	0f 90       	pop	r0
 5ec:	0f be       	out	0x3f, r0	; 63
 5ee:	0f 90       	pop	r0
 5f0:	1f 90       	pop	r1
 5f2:	18 95       	reti

000005f4 <_GLOBAL__sub_I_bufferUART_RX>:

#ifndef RINGBUFFER_H_
#define RINGBUFFER_H_

template <uint8_t BUFFER_SIZE>
class RingBuffer
 5f4:	e6 e7       	ldi	r30, 0x76	; 118
 5f6:	ff e3       	ldi	r31, 0x3F	; 63
 5f8:	80 e2       	ldi	r24, 0x20	; 32
 5fa:	80 83       	st	Z, r24
 5fc:	11 a2       	std	Z+33, r1	; 0x21
 5fe:	12 a2       	std	Z+34, r1	; 0x22
 600:	e3 e6       	ldi	r30, 0x63	; 99
 602:	ff e3       	ldi	r31, 0x3F	; 63
 604:	80 e1       	ldi	r24, 0x10	; 16
 606:	80 83       	st	Z, r24
 608:	11 8a       	std	Z+17, r1	; 0x11
 60a:	12 8a       	std	Z+18, r1	; 0x12
 60c:	08 95       	ret

0000060e <__tablejump2__>:
 60e:	ee 0f       	add	r30, r30
 610:	ff 1f       	adc	r31, r31
 612:	05 90       	lpm	r0, Z+
 614:	f4 91       	lpm	r31, Z
 616:	e0 2d       	mov	r30, r0
 618:	09 94       	ijmp

0000061a <_exit>:
 61a:	f8 94       	cli

0000061c <__stop_program>:
 61c:	ff cf       	rjmp	.-2      	; 0x61c <__stop_program>
