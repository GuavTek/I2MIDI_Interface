
I2MIDI_Interface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803f00  00803f00  000007a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000072e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000099  00803f00  00803f00  000007a2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000007a2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000007d4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  00000810  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000041eb  00000000  00000000  00000978  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001d84  00000000  00000000  00004b63  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d73  00000000  00000000  000068e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003e4  00000000  00000000  0000765c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b0b  00000000  00000000  00007a40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007f9  00000000  00000000  0000954b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00009d44  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	1b c0       	rjmp	.+54     	; 0x38 <__ctors_end>
   2:	34 c0       	rjmp	.+104    	; 0x6c <__bad_interrupt>
   4:	33 c0       	rjmp	.+102    	; 0x6c <__bad_interrupt>
   6:	32 c0       	rjmp	.+100    	; 0x6c <__bad_interrupt>
   8:	31 c0       	rjmp	.+98     	; 0x6c <__bad_interrupt>
   a:	30 c0       	rjmp	.+96     	; 0x6c <__bad_interrupt>
   c:	2f c0       	rjmp	.+94     	; 0x6c <__bad_interrupt>
   e:	2e c0       	rjmp	.+92     	; 0x6c <__bad_interrupt>
  10:	ed c1       	rjmp	.+986    	; 0x3ec <__vector_8>
  12:	2c c0       	rjmp	.+88     	; 0x6c <__bad_interrupt>
  14:	2b c0       	rjmp	.+86     	; 0x6c <__bad_interrupt>
  16:	2a c0       	rjmp	.+84     	; 0x6c <__bad_interrupt>
  18:	29 c0       	rjmp	.+82     	; 0x6c <__bad_interrupt>
  1a:	b6 c1       	rjmp	.+876    	; 0x388 <__vector_13>
  1c:	27 c0       	rjmp	.+78     	; 0x6c <__bad_interrupt>
  1e:	26 c0       	rjmp	.+76     	; 0x6c <__bad_interrupt>
  20:	25 c0       	rjmp	.+74     	; 0x6c <__bad_interrupt>
  22:	24 c0       	rjmp	.+72     	; 0x6c <__bad_interrupt>
  24:	23 c0       	rjmp	.+70     	; 0x6c <__bad_interrupt>
  26:	3e c1       	rjmp	.+636    	; 0x2a4 <__vector_19>
  28:	d9 c0       	rjmp	.+434    	; 0x1dc <__vector_20>
  2a:	20 c0       	rjmp	.+64     	; 0x6c <__bad_interrupt>
  2c:	bd c2       	rjmp	.+1402   	; 0x5a8 <__vector_22>
  2e:	2a c3       	rjmp	.+1620   	; 0x684 <__vector_23>
  30:	1d c0       	rjmp	.+58     	; 0x6c <__bad_interrupt>
  32:	1c c0       	rjmp	.+56     	; 0x6c <__bad_interrupt>

00000034 <__ctors_start>:
  34:	80 01       	movw	r16, r0
  36:	82 03       	fmuls	r16, r18

00000038 <__ctors_end>:
  38:	11 24       	eor	r1, r1
  3a:	1f be       	out	0x3f, r1	; 63
  3c:	cf ef       	ldi	r28, 0xFF	; 255
  3e:	cd bf       	out	0x3d, r28	; 61
  40:	df e3       	ldi	r29, 0x3F	; 63
  42:	de bf       	out	0x3e, r29	; 62

00000044 <__do_clear_bss>:
  44:	2f e3       	ldi	r18, 0x3F	; 63
  46:	a0 e0       	ldi	r26, 0x00	; 0
  48:	bf e3       	ldi	r27, 0x3F	; 63
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
  4e:	a9 39       	cpi	r26, 0x99	; 153
  50:	b2 07       	cpc	r27, r18
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>

00000054 <__do_global_ctors>:
  54:	10 e0       	ldi	r17, 0x00	; 0
  56:	cc e1       	ldi	r28, 0x1C	; 28
  58:	d0 e0       	ldi	r29, 0x00	; 0
  5a:	03 c0       	rjmp	.+6      	; 0x62 <__do_global_ctors+0xe>
  5c:	21 97       	sbiw	r28, 0x01	; 1
  5e:	fe 01       	movw	r30, r28
  60:	5e d3       	rcall	.+1724   	; 0x71e <__tablejump2__>
  62:	ca 31       	cpi	r28, 0x1A	; 26
  64:	d1 07       	cpc	r29, r17
  66:	d1 f7       	brne	.-12     	; 0x5c <__do_global_ctors+0x8>
  68:	57 d2       	rcall	.+1198   	; 0x518 <main>
  6a:	5f c3       	rjmp	.+1726   	; 0x72a <_exit>

0000006c <__bad_interrupt>:
  6c:	c9 cf       	rjmp	.-110    	; 0x0 <__vectors>

0000006e <_Z8I2C_Initv>:
}

//Returns amount of data in RX buffer
uint8_t RXCountI2C(){
	return I2Cbuffer_RX.Count();
}
  6e:	83 e0       	ldi	r24, 0x03	; 3
  70:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <__TEXT_REGION_LENGTH__+0x700425>
  74:	e0 e1       	ldi	r30, 0x10	; 16
  76:	f8 e0       	ldi	r31, 0x08	; 8
  78:	83 e6       	ldi	r24, 0x63	; 99
  7a:	86 83       	std	Z+6, r24	; 0x06
  7c:	81 e4       	ldi	r24, 0x41	; 65
  7e:	83 83       	std	Z+3, r24	; 0x03
  80:	88 e0       	ldi	r24, 0x08	; 8
  82:	84 83       	std	Z+4, r24	; 0x04
  84:	81 e0       	ldi	r24, 0x01	; 1
  86:	85 83       	std	Z+5, r24	; 0x05
  88:	88 ed       	ldi	r24, 0xD8	; 216
  8a:	84 87       	std	Z+12, r24	; 0x0c
  8c:	83 e8       	ldi	r24, 0x83	; 131
  8e:	81 87       	std	Z+9, r24	; 0x09
  90:	08 95       	ret

00000092 <_Z15EndTransmissionv>:
  92:	e0 e1       	ldi	r30, 0x10	; 16
  94:	f8 e0       	ldi	r31, 0x08	; 8
  96:	84 81       	ldd	r24, Z+4	; 0x04
  98:	83 60       	ori	r24, 0x03	; 3
  9a:	84 83       	std	Z+4, r24	; 0x04
  9c:	10 92 47 3f 	sts	0x3F47, r1	; 0x803f47 <isTransmitting>
  a0:	08 95       	ret

000000a2 <_ZN10RingBufferILh16EE5CountEv>:
	}
}

//Returns how many elements are in the buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Count(){
  a2:	fc 01       	movw	r30, r24
	//Compensate for overflows
	if (head >= tail)
  a4:	81 89       	ldd	r24, Z+17	; 0x11
  a6:	22 89       	ldd	r18, Z+18	; 0x12
  a8:	82 17       	cp	r24, r18
  aa:	10 f0       	brcs	.+4      	; 0xb0 <_ZN10RingBufferILh16EE5CountEv+0xe>
	{
		return (head - tail);
  ac:	82 1b       	sub	r24, r18
  ae:	08 95       	ret
	} else {
		return (head - tail + length);
  b0:	90 81       	ld	r25, Z
  b2:	89 0f       	add	r24, r25
  b4:	82 1b       	sub	r24, r18
	}
}
  b6:	08 95       	ret

000000b8 <_Z12WordCountI2Cv>:
  b8:	89 e4       	ldi	r24, 0x49	; 73
  ba:	9f e3       	ldi	r25, 0x3F	; 63
  bc:	f2 df       	rcall	.-28     	; 0xa2 <_ZN10RingBufferILh16EE5CountEv>
  be:	08 95       	ret

000000c0 <_Z9WordReadyh>:
  c0:	cf 93       	push	r28
  c2:	c8 2f       	mov	r28, r24
  c4:	89 e4       	ldi	r24, 0x49	; 73
  c6:	9f e3       	ldi	r25, 0x3F	; 63
  c8:	ec df       	rcall	.-40     	; 0xa2 <_ZN10RingBufferILh16EE5CountEv>
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	40 91 49 3f 	lds	r20, 0x3F49	; 0x803f49 <wordLength>
  d0:	24 2f       	mov	r18, r20
  d2:	30 e0       	ldi	r19, 0x00	; 0
  d4:	b9 01       	movw	r22, r18
  d6:	61 50       	subi	r22, 0x01	; 1
  d8:	71 09       	sbc	r23, r1
  da:	86 17       	cp	r24, r22
  dc:	97 07       	cpc	r25, r23
  de:	bc f4       	brge	.+46     	; 0x10e <_Z9WordReadyh+0x4e>
  e0:	22 50       	subi	r18, 0x02	; 2
  e2:	31 09       	sbc	r19, r1
  e4:	82 17       	cp	r24, r18
  e6:	93 07       	cpc	r25, r19
  e8:	a4 f4       	brge	.+40     	; 0x112 <_Z9WordReadyh+0x52>
  ea:	80 91 5a 3f 	lds	r24, 0x3F5A	; 0x803f5a <wordLength+0x11>
  ee:	8f 5f       	subi	r24, 0xFF	; 255
  f0:	84 17       	cp	r24, r20
  f2:	18 f4       	brcc	.+6      	; 0xfa <_Z9WordReadyh+0x3a>
  f4:	80 93 5a 3f 	sts	0x3F5A, r24	; 0x803f5a <wordLength+0x11>
  f8:	02 c0       	rjmp	.+4      	; 0xfe <_Z9WordReadyh+0x3e>
  fa:	10 92 5a 3f 	sts	0x3F5A, r1	; 0x803f5a <wordLength+0x11>
  fe:	e0 91 5a 3f 	lds	r30, 0x3F5A	; 0x803f5a <wordLength+0x11>
 102:	f0 e0       	ldi	r31, 0x00	; 0
 104:	e7 5b       	subi	r30, 0xB7	; 183
 106:	f0 4c       	sbci	r31, 0xC0	; 192
 108:	c1 83       	std	Z+1, r28	; 0x01
 10a:	80 e0       	ldi	r24, 0x00	; 0
 10c:	03 c0       	rjmp	.+6      	; 0x114 <_Z9WordReadyh+0x54>
 10e:	81 e0       	ldi	r24, 0x01	; 1
 110:	01 c0       	rjmp	.+2      	; 0x114 <_Z9WordReadyh+0x54>
 112:	80 e0       	ldi	r24, 0x00	; 0
 114:	cf 91       	pop	r28
 116:	08 95       	ret

00000118 <_ZN10RingBufferILh32EE5CountEv>:
	}
}

//Returns how many elements are in the buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Count(){
 118:	fc 01       	movw	r30, r24
	//Compensate for overflows
	if (head >= tail)
 11a:	81 a1       	ldd	r24, Z+33	; 0x21
 11c:	22 a1       	ldd	r18, Z+34	; 0x22
 11e:	82 17       	cp	r24, r18
 120:	10 f0       	brcs	.+4      	; 0x126 <_ZN10RingBufferILh32EE5CountEv+0xe>
	{
		return (head - tail);
 122:	82 1b       	sub	r24, r18
 124:	08 95       	ret
	} else {
		return (head - tail + length);
 126:	90 81       	ld	r25, Z
 128:	89 0f       	add	r24, r25
 12a:	82 1b       	sub	r24, r18
	}
}
 12c:	08 95       	ret

0000012e <_ZN10RingBufferILh32EE4ReadEv>:
}
*/

//Read the next byte in buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Read(){
 12e:	cf 93       	push	r28
 130:	df 93       	push	r29
 132:	ec 01       	movw	r28, r24
	if (Count() > 0)
 134:	f1 df       	rcall	.-30     	; 0x118 <_ZN10RingBufferILh32EE5CountEv>
 136:	88 23       	and	r24, r24
 138:	59 f0       	breq	.+22     	; 0x150 <_ZN10RingBufferILh32EE4ReadEv+0x22>
	{
		tail++;
 13a:	8a a1       	ldd	r24, Y+34	; 0x22
 13c:	8f 5f       	subi	r24, 0xFF	; 255
 13e:	8a a3       	std	Y+34, r24	; 0x22
		if (tail >= length)
 140:	98 81       	ld	r25, Y
 142:	89 17       	cp	r24, r25
 144:	08 f0       	brcs	.+2      	; 0x148 <_ZN10RingBufferILh32EE4ReadEv+0x1a>
		{
			tail = 0;
 146:	1a a2       	std	Y+34, r1	; 0x22
		}
		return buffer[tail];
 148:	8a a1       	ldd	r24, Y+34	; 0x22
 14a:	c8 0f       	add	r28, r24
 14c:	d1 1d       	adc	r29, r1
 14e:	89 81       	ldd	r24, Y+1	; 0x01
	}
	return 0;
}
 150:	df 91       	pop	r29
 152:	cf 91       	pop	r28
 154:	08 95       	ret

00000156 <_Z7SendI2Ch>:
 156:	88 23       	and	r24, r24
 158:	71 f0       	breq	.+28     	; 0x176 <_Z7SendI2Ch+0x20>
 15a:	80 91 48 3f 	lds	r24, 0x3F48	; 0x803f48 <currentWord>
 15e:	81 11       	cpse	r24, r1
 160:	02 c0       	rjmp	.+4      	; 0x166 <_Z7SendI2Ch+0x10>
 162:	97 df       	rcall	.-210    	; 0x92 <_Z15EndTransmissionv>
 164:	08 95       	ret
 166:	81 50       	subi	r24, 0x01	; 1
 168:	80 93 48 3f 	sts	0x3F48, r24	; 0x803f48 <currentWord>
 16c:	80 e0       	ldi	r24, 0x00	; 0
 16e:	9f e3       	ldi	r25, 0x3F	; 63
 170:	de df       	rcall	.-68     	; 0x12e <_ZN10RingBufferILh32EE4ReadEv>
 172:	80 93 5c 3f 	sts	0x3F5C, r24	; 0x803f5c <currentChar>
 176:	81 e0       	ldi	r24, 0x01	; 1
 178:	80 93 46 3f 	sts	0x3F46, r24	; 0x803f46 <addressDone>
 17c:	80 91 5c 3f 	lds	r24, 0x3F5C	; 0x803f5c <currentChar>
 180:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <__TEXT_REGION_LENGTH__+0x700818>
 184:	f8 d0       	rcall	.+496    	; 0x376 <_Z12I2C_Activityv>
 186:	08 95       	ret

00000188 <_Z17StartTransmissionv>:
 188:	80 91 47 3f 	lds	r24, 0x3F47	; 0x803f47 <isTransmitting>
 18c:	81 11       	cpse	r24, r1
 18e:	25 c0       	rjmp	.+74     	; 0x1da <_Z17StartTransmissionv+0x52>
 190:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 194:	83 70       	andi	r24, 0x03	; 3
 196:	83 30       	cpi	r24, 0x03	; 3
 198:	01 f1       	breq	.+64     	; 0x1da <_Z17StartTransmissionv+0x52>
 19a:	88 ed       	ldi	r24, 0xD8	; 216
 19c:	80 93 17 08 	sts	0x0817, r24	; 0x800817 <__TEXT_REGION_LENGTH__+0x700817>
 1a0:	89 e4       	ldi	r24, 0x49	; 73
 1a2:	9f e3       	ldi	r25, 0x3F	; 63
 1a4:	7e df       	rcall	.-260    	; 0xa2 <_ZN10RingBufferILh16EE5CountEv>
 1a6:	88 23       	and	r24, r24
 1a8:	81 f0       	breq	.+32     	; 0x1ca <_Z17StartTransmissionv+0x42>
 1aa:	e9 e4       	ldi	r30, 0x49	; 73
 1ac:	ff e3       	ldi	r31, 0x3F	; 63
 1ae:	82 89       	ldd	r24, Z+18	; 0x12
 1b0:	8f 5f       	subi	r24, 0xFF	; 255
 1b2:	82 8b       	std	Z+18, r24	; 0x12
 1b4:	90 81       	ld	r25, Z
 1b6:	89 17       	cp	r24, r25
 1b8:	10 f0       	brcs	.+4      	; 0x1be <_Z17StartTransmissionv+0x36>
 1ba:	10 92 5b 3f 	sts	0x3F5B, r1	; 0x803f5b <wordLength+0x12>
 1be:	e0 91 5b 3f 	lds	r30, 0x3F5B	; 0x803f5b <wordLength+0x12>
 1c2:	f0 e0       	ldi	r31, 0x00	; 0
 1c4:	e7 5b       	subi	r30, 0xB7	; 183
 1c6:	f0 4c       	sbci	r31, 0xC0	; 192
 1c8:	81 81       	ldd	r24, Z+1	; 0x01
 1ca:	80 93 48 3f 	sts	0x3F48, r24	; 0x803f48 <currentWord>
 1ce:	10 92 46 3f 	sts	0x3F46, r1	; 0x803f46 <addressDone>
 1d2:	81 e0       	ldi	r24, 0x01	; 1
 1d4:	80 93 47 3f 	sts	0x3F47, r24	; 0x803f47 <isTransmitting>
 1d8:	be df       	rcall	.-132    	; 0x156 <_Z7SendI2Ch>
 1da:	08 95       	ret

000001dc <__vector_20>:
 1dc:	1f 92       	push	r1
 1de:	0f 92       	push	r0
 1e0:	0f b6       	in	r0, 0x3f	; 63
 1e2:	0f 92       	push	r0
 1e4:	11 24       	eor	r1, r1
 1e6:	2f 93       	push	r18
 1e8:	3f 93       	push	r19
 1ea:	4f 93       	push	r20
 1ec:	5f 93       	push	r21
 1ee:	6f 93       	push	r22
 1f0:	7f 93       	push	r23
 1f2:	8f 93       	push	r24
 1f4:	9f 93       	push	r25
 1f6:	af 93       	push	r26
 1f8:	bf 93       	push	r27
 1fa:	ef 93       	push	r30
 1fc:	ff 93       	push	r31
 1fe:	80 91 15 08 	lds	r24, 0x0815	; 0x800815 <__TEXT_REGION_LENGTH__+0x700815>
 202:	83 ff       	sbrs	r24, 3
 204:	0c c0       	rjmp	.+24     	; 0x21e <__vector_20+0x42>
 206:	80 91 46 3f 	lds	r24, 0x3F46	; 0x803f46 <addressDone>
 20a:	88 23       	and	r24, r24
 20c:	11 f0       	breq	.+4      	; 0x212 <__vector_20+0x36>
 20e:	80 e0       	ldi	r24, 0x00	; 0
 210:	a2 df       	rcall	.-188    	; 0x156 <_Z7SendI2Ch>
 212:	e0 e1       	ldi	r30, 0x10	; 16
 214:	f8 e0       	ldi	r31, 0x08	; 8
 216:	85 81       	ldd	r24, Z+5	; 0x05
 218:	88 60       	ori	r24, 0x08	; 8
 21a:	85 83       	std	Z+5, r24	; 0x05
 21c:	02 c0       	rjmp	.+4      	; 0x222 <__vector_20+0x46>
 21e:	81 e0       	ldi	r24, 0x01	; 1
 220:	9a df       	rcall	.-204    	; 0x156 <_Z7SendI2Ch>
 222:	ff 91       	pop	r31
 224:	ef 91       	pop	r30
 226:	bf 91       	pop	r27
 228:	af 91       	pop	r26
 22a:	9f 91       	pop	r25
 22c:	8f 91       	pop	r24
 22e:	7f 91       	pop	r23
 230:	6f 91       	pop	r22
 232:	5f 91       	pop	r21
 234:	4f 91       	pop	r20
 236:	3f 91       	pop	r19
 238:	2f 91       	pop	r18
 23a:	0f 90       	pop	r0
 23c:	0f be       	out	0x3f, r0	; 63
 23e:	0f 90       	pop	r0
 240:	1f 90       	pop	r1
 242:	18 95       	reti

00000244 <_ZN10RingBufferILh32EE5WriteEh>:
	return buffer[tempTail];
}

//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
 244:	1f 93       	push	r17
 246:	cf 93       	push	r28
 248:	df 93       	push	r29
 24a:	ec 01       	movw	r28, r24
 24c:	16 2f       	mov	r17, r22
	if (Count() < length - 2)
 24e:	64 df       	rcall	.-312    	; 0x118 <_ZN10RingBufferILh32EE5CountEv>
 250:	48 81       	ld	r20, Y
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	24 2f       	mov	r18, r20
 256:	30 e0       	ldi	r19, 0x00	; 0
 258:	22 50       	subi	r18, 0x02	; 2
 25a:	31 09       	sbc	r19, r1
 25c:	82 17       	cp	r24, r18
 25e:	93 07       	cpc	r25, r19
 260:	5c f4       	brge	.+22     	; 0x278 <_ZN10RingBufferILh32EE5WriteEh+0x34>
	{
		head++;
 262:	89 a1       	ldd	r24, Y+33	; 0x21
 264:	8f 5f       	subi	r24, 0xFF	; 255
		
		if (head >= length)
 266:	84 17       	cp	r24, r20
 268:	10 f4       	brcc	.+4      	; 0x26e <_ZN10RingBufferILh32EE5WriteEh+0x2a>
//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
	{
		head++;
 26a:	89 a3       	std	Y+33, r24	; 0x21
 26c:	01 c0       	rjmp	.+2      	; 0x270 <_ZN10RingBufferILh32EE5WriteEh+0x2c>
		
		if (head >= length)
		{
			head = 0;
 26e:	19 a2       	std	Y+33, r1	; 0x21
		}
		
		buffer[head] = in;
 270:	89 a1       	ldd	r24, Y+33	; 0x21
 272:	c8 0f       	add	r28, r24
 274:	d1 1d       	adc	r29, r1
 276:	19 83       	std	Y+1, r17	; 0x01
	}
}
 278:	df 91       	pop	r29
 27a:	cf 91       	pop	r28
 27c:	1f 91       	pop	r17
 27e:	08 95       	ret

00000280 <_Z5TXI2Ch>:
uint8_t WordCountI2C(){
	return wordLength.Count();
}

//Loads I2C byte into buffer
uint8_t TXI2C(uint8_t msg){
 280:	cf 93       	push	r28
 282:	c8 2f       	mov	r28, r24
	if (I2Cbuffer_TX.Count() > I2Cbuffer_TX.length)
 284:	80 e0       	ldi	r24, 0x00	; 0
 286:	9f e3       	ldi	r25, 0x3F	; 63
 288:	47 df       	rcall	.-370    	; 0x118 <_ZN10RingBufferILh32EE5CountEv>
 28a:	90 91 00 3f 	lds	r25, 0x3F00	; 0x803f00 <_edata>
 28e:	98 17       	cp	r25, r24
 290:	30 f0       	brcs	.+12     	; 0x29e <_Z5TXI2Ch+0x1e>
	{
		return 1;
	}
	I2Cbuffer_TX.Write(msg);
 292:	6c 2f       	mov	r22, r28
 294:	80 e0       	ldi	r24, 0x00	; 0
 296:	9f e3       	ldi	r25, 0x3F	; 63
 298:	d5 df       	rcall	.-86     	; 0x244 <_ZN10RingBufferILh32EE5WriteEh>
	return 0;
 29a:	80 e0       	ldi	r24, 0x00	; 0
 29c:	01 c0       	rjmp	.+2      	; 0x2a0 <_Z5TXI2Ch+0x20>

//Loads I2C byte into buffer
uint8_t TXI2C(uint8_t msg){
	if (I2Cbuffer_TX.Count() > I2Cbuffer_TX.length)
	{
		return 1;
 29e:	81 e0       	ldi	r24, 0x01	; 1
	}
	I2Cbuffer_TX.Write(msg);
	return 0;
}
 2a0:	cf 91       	pop	r28
 2a2:	08 95       	ret

000002a4 <__vector_19>:

//Slave interrupt
ISR(TWI0_TWIS_vect){
 2a4:	1f 92       	push	r1
 2a6:	0f 92       	push	r0
 2a8:	0f b6       	in	r0, 0x3f	; 63
 2aa:	0f 92       	push	r0
 2ac:	11 24       	eor	r1, r1
 2ae:	2f 93       	push	r18
 2b0:	3f 93       	push	r19
 2b2:	4f 93       	push	r20
 2b4:	5f 93       	push	r21
 2b6:	6f 93       	push	r22
 2b8:	7f 93       	push	r23
 2ba:	8f 93       	push	r24
 2bc:	9f 93       	push	r25
 2be:	af 93       	push	r26
 2c0:	bf 93       	push	r27
 2c2:	cf 93       	push	r28
 2c4:	df 93       	push	r29
 2c6:	ef 93       	push	r30
 2c8:	ff 93       	push	r31
	I2Cbuffer_RX.Write(TWI0.SDATA);
 2ca:	c0 e1       	ldi	r28, 0x10	; 16
 2cc:	d8 e0       	ldi	r29, 0x08	; 8
 2ce:	6d 85       	ldd	r22, Y+13	; 0x0d
 2d0:	83 e2       	ldi	r24, 0x23	; 35
 2d2:	9f e3       	ldi	r25, 0x3F	; 63
 2d4:	b7 df       	rcall	.-146    	; 0x244 <_ZN10RingBufferILh32EE5WriteEh>
	TWI0.SCTRLB = TWI_SCMD_RESPONSE_gc;
 2d6:	83 e0       	ldi	r24, 0x03	; 3
 2d8:	8a 87       	std	Y+10, r24	; 0x0a
	//TWI0_SCTRLB = TWI_SCMD_RESPONSE_gc;
}
 2da:	ff 91       	pop	r31
 2dc:	ef 91       	pop	r30
 2de:	df 91       	pop	r29
 2e0:	cf 91       	pop	r28
 2e2:	bf 91       	pop	r27
 2e4:	af 91       	pop	r26
 2e6:	9f 91       	pop	r25
 2e8:	8f 91       	pop	r24
 2ea:	7f 91       	pop	r23
 2ec:	6f 91       	pop	r22
 2ee:	5f 91       	pop	r21
 2f0:	4f 91       	pop	r20
 2f2:	3f 91       	pop	r19
 2f4:	2f 91       	pop	r18
 2f6:	0f 90       	pop	r0
 2f8:	0f be       	out	0x3f, r0	; 63
 2fa:	0f 90       	pop	r0
 2fc:	1f 90       	pop	r1
 2fe:	18 95       	reti

00000300 <_GLOBAL__sub_I_currentChar>:

#ifndef RINGBUFFER_H_
#define RINGBUFFER_H_

template <uint8_t BUFFER_SIZE>
class RingBuffer
 300:	e9 e4       	ldi	r30, 0x49	; 73
 302:	ff e3       	ldi	r31, 0x3F	; 63
 304:	80 e1       	ldi	r24, 0x10	; 16
 306:	80 83       	st	Z, r24
 308:	11 8a       	std	Z+17, r1	; 0x11
 30a:	12 8a       	std	Z+18, r1	; 0x12
 30c:	e3 e2       	ldi	r30, 0x23	; 35
 30e:	ff e3       	ldi	r31, 0x3F	; 63
 310:	80 e2       	ldi	r24, 0x20	; 32
 312:	80 83       	st	Z, r24
 314:	11 a2       	std	Z+33, r1	; 0x21
 316:	12 a2       	std	Z+34, r1	; 0x22
 318:	e0 e0       	ldi	r30, 0x00	; 0
 31a:	ff e3       	ldi	r31, 0x3F	; 63
 31c:	80 83       	st	Z, r24
 31e:	11 a2       	std	Z+33, r1	; 0x21
 320:	12 a2       	std	Z+34, r1	; 0x22
 322:	08 95       	ret

00000324 <_Z8Led_Initv>:

#include "Includes.h"

void Led_Init(){
	//Set clk
	TCB0.CTRLA = TCB_CLKSEL_CLKDIV2_gc;
 324:	e0 e4       	ldi	r30, 0x40	; 64
 326:	fa e0       	ldi	r31, 0x0A	; 10
 328:	82 e0       	ldi	r24, 0x02	; 2
 32a:	80 83       	st	Z, r24

	//Enable interrupt
	TCB0.INTCTRL = TCB_CAPT_bm;
 32c:	81 e0       	ldi	r24, 0x01	; 1
 32e:	85 83       	std	Z+5, r24	; 0x05
	
	TCB0.DBGCTRL = Debug;
 330:	80 87       	std	Z+8, r24	; 0x08
	
	//Periodic interrupt mode
	TCB0.CTRLB = TCB_CNTMODE_INT_gc;
 332:	11 82       	std	Z+1, r1	; 0x01
	
	//Set period
	TCB0.CCMP = 8000;
 334:	80 e4       	ldi	r24, 0x40	; 64
 336:	9f e1       	ldi	r25, 0x1F	; 31
 338:	84 87       	std	Z+12, r24	; 0x0c
 33a:	95 87       	std	Z+13, r25	; 0x0d
	
	//Enable timer
	TCB0.CTRLA |= TCB_ENABLE_bm;
 33c:	80 81       	ld	r24, Z
 33e:	81 60       	ori	r24, 0x01	; 1
 340:	80 83       	st	Z, r24
	
	TCB0.DBGCTRL |= Debug;
 342:	80 85       	ldd	r24, Z+8	; 0x08
 344:	81 60       	ori	r24, 0x01	; 1
 346:	80 87       	std	Z+8, r24	; 0x08

	//Enable LED outputs
	PORTA.DIRSET = PIN7_bm; //I2C
 348:	e0 e0       	ldi	r30, 0x00	; 0
 34a:	f4 e0       	ldi	r31, 0x04	; 4
 34c:	80 e8       	ldi	r24, 0x80	; 128
 34e:	81 83       	std	Z+1, r24	; 0x01
	PORTB.DIRSET = PIN4_bm; //DIN
 350:	a0 e2       	ldi	r26, 0x20	; 32
 352:	b4 e0       	ldi	r27, 0x04	; 4
 354:	90 e1       	ldi	r25, 0x10	; 16
 356:	11 96       	adiw	r26, 0x01	; 1
 358:	9c 93       	st	X, r25
 35a:	11 97       	sbiw	r26, 0x01	; 1
	
	PORTB.OUTSET = PIN4_bm;
 35c:	15 96       	adiw	r26, 0x05	; 5
 35e:	9c 93       	st	X, r25
	PORTA.OUTSET = PIN7_bm;
 360:	85 83       	std	Z+5, r24	; 0x05
 362:	08 95       	ret

00000364 <_Z13UART_Activityv>:
}

void UART_Activity(){
	PORTB.OUTSET = PIN4_bm;
 364:	80 e1       	ldi	r24, 0x10	; 16
 366:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <__TEXT_REGION_LENGTH__+0x700425>
	TCB0.CTRLA |= TCB_ENABLE_bm;
 36a:	e0 e4       	ldi	r30, 0x40	; 64
 36c:	fa e0       	ldi	r31, 0x0A	; 10
 36e:	80 81       	ld	r24, Z
 370:	81 60       	ori	r24, 0x01	; 1
 372:	80 83       	st	Z, r24
 374:	08 95       	ret

00000376 <_Z12I2C_Activityv>:
}

void I2C_Activity(){
	PORTA.OUTSET = PIN7_bm;
 376:	80 e8       	ldi	r24, 0x80	; 128
 378:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <__TEXT_REGION_LENGTH__+0x700405>
	TCB0.CTRLA |= TCB_ENABLE_bm;
 37c:	e0 e4       	ldi	r30, 0x40	; 64
 37e:	fa e0       	ldi	r31, 0x0A	; 10
 380:	80 81       	ld	r24, Z
 382:	81 60       	ori	r24, 0x01	; 1
 384:	80 83       	st	Z, r24
 386:	08 95       	ret

00000388 <__vector_13>:
}

ISR(TCB0_INT_vect){
 388:	1f 92       	push	r1
 38a:	0f 92       	push	r0
 38c:	0f b6       	in	r0, 0x3f	; 63
 38e:	0f 92       	push	r0
 390:	11 24       	eor	r1, r1
 392:	8f 93       	push	r24
 394:	ef 93       	push	r30
 396:	ff 93       	push	r31
	//Clear flag
	TCB0.INTFLAGS = TCB_CAPT_bm;
 398:	e0 e4       	ldi	r30, 0x40	; 64
 39a:	fa e0       	ldi	r31, 0x0A	; 10
 39c:	81 e0       	ldi	r24, 0x01	; 1
 39e:	86 83       	std	Z+6, r24	; 0x06
	
	//Disable timer
	TCB0.CTRLA &= ~(TCB_ENABLE_bm);
 3a0:	80 81       	ld	r24, Z
 3a2:	8e 7f       	andi	r24, 0xFE	; 254
 3a4:	80 83       	st	Z, r24
	
	//Turn off leds
	PORTA.OUTCLR = PIN7_bm;
 3a6:	80 e8       	ldi	r24, 0x80	; 128
 3a8:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <__TEXT_REGION_LENGTH__+0x700406>
	PORTB.OUTCLR = PIN4_bm;
 3ac:	80 e1       	ldi	r24, 0x10	; 16
 3ae:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <__TEXT_REGION_LENGTH__+0x700426>
 3b2:	ff 91       	pop	r31
 3b4:	ef 91       	pop	r30
 3b6:	8f 91       	pop	r24
 3b8:	0f 90       	pop	r0
 3ba:	0f be       	out	0x3f, r0	; 63
 3bc:	0f 90       	pop	r0
 3be:	1f 90       	pop	r1
 3c0:	18 95       	reti

000003c2 <_Z8CLK_Initv>:
    }
}

void CLK_Init(){
	//Disable prescaler
	CCP = CCP_IOREG_gc;
 3c2:	88 ed       	ldi	r24, 0xD8	; 216
 3c4:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB &= ~CLKCTRL_PEN_bm;
 3c6:	e0 e6       	ldi	r30, 0x60	; 96
 3c8:	f0 e0       	ldi	r31, 0x00	; 0
 3ca:	81 81       	ldd	r24, Z+1	; 0x01
 3cc:	8e 7f       	andi	r24, 0xFE	; 254
 3ce:	81 83       	std	Z+1, r24	; 0x01
 3d0:	08 95       	ret

000003d2 <_Z10Timer_Initv>:
}

void Timer_Init(){
	//Set normal mode.
	TCA0.SINGLE.CTRLB = TCA_SINGLE_WGMODE_NORMAL_gc;
 3d2:	e0 e0       	ldi	r30, 0x00	; 0
 3d4:	fa e0       	ldi	r31, 0x0A	; 10
 3d6:	11 82       	std	Z+1, r1	; 0x01
	
	//Set timer period = 1ms
	TCA0.SINGLE.PER = 1250;
 3d8:	82 ee       	ldi	r24, 0xE2	; 226
 3da:	94 e0       	ldi	r25, 0x04	; 4
 3dc:	86 a3       	std	Z+38, r24	; 0x26
 3de:	97 a3       	std	Z+39, r25	; 0x27
	
	//Enable interrupt
	TCA0.SINGLE.INTCTRL = TCA_SINGLE_OVF_bm;
 3e0:	81 e0       	ldi	r24, 0x01	; 1
 3e2:	82 87       	std	Z+10, r24	; 0x0a
	
	TCA0.SINGLE.DBGCTRL = Debug;
 3e4:	86 87       	std	Z+14, r24	; 0x0e
	
	//Enable timer
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc|TCA_SINGLE_ENABLE_bm;
 3e6:	89 e0       	ldi	r24, 0x09	; 9
 3e8:	80 83       	st	Z, r24
 3ea:	08 95       	ret

000003ec <__vector_8>:
			status.dinDone = 1;
		}
	}
}

ISR(TCA0_OVF_vect){
 3ec:	1f 92       	push	r1
 3ee:	0f 92       	push	r0
 3f0:	0f b6       	in	r0, 0x3f	; 63
 3f2:	0f 92       	push	r0
 3f4:	11 24       	eor	r1, r1
 3f6:	8f 93       	push	r24
	//Clear interrupt flag
	TCA0.SINGLE.INTFLAGS = TCA_SINGLE_OVF_bm;
 3f8:	81 e0       	ldi	r24, 0x01	; 1
 3fa:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <__TEXT_REGION_LENGTH__+0x700a0b>
	
	//Byte timeout, switch source
	if (status.currentSource == DIN5)
 3fe:	80 91 5f 3f 	lds	r24, 0x3F5F	; 0x803f5f <status+0x1>
 402:	81 11       	cpse	r24, r1
 404:	04 c0       	rjmp	.+8      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
	{
		status.currentSource = I2C;
 406:	81 e0       	ldi	r24, 0x01	; 1
 408:	80 93 5f 3f 	sts	0x3F5F, r24	; 0x803f5f <status+0x1>
 40c:	02 c0       	rjmp	.+4      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
	} 
	else
	{
		status.currentSource = DIN5;
 40e:	10 92 5f 3f 	sts	0x3F5F, r1	; 0x803f5f <status+0x1>
	}
}
 412:	8f 91       	pop	r24
 414:	0f 90       	pop	r0
 416:	0f be       	out	0x3f, r0	; 63
 418:	0f 90       	pop	r0
 41a:	1f 90       	pop	r1
 41c:	18 95       	reti

0000041e <_Z5Mergev>:
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV16_gc|TCA_SINGLE_ENABLE_bm;
}


void Merge(){
	if (status.dinDone && status.I2CDone) {
 41e:	80 91 60 3f 	lds	r24, 0x3F60	; 0x803f60 <status+0x2>
 422:	88 23       	and	r24, r24
 424:	09 f4       	brne	.+2      	; 0x428 <_Z5Mergev+0xa>
 426:	62 c0       	rjmp	.+196    	; 0x4ec <_Z5Mergev+0xce>
 428:	80 91 61 3f 	lds	r24, 0x3F61	; 0x803f61 <status+0x3>
 42c:	88 23       	and	r24, r24
 42e:	09 f4       	brne	.+2      	; 0x432 <_Z5Mergev+0x14>
 430:	61 c0       	rjmp	.+194    	; 0x4f4 <_Z5Mergev+0xd6>
		//Get character
		if (status.currentSource == DIN5)
 432:	80 91 5f 3f 	lds	r24, 0x3F5F	; 0x803f5f <status+0x1>
 436:	81 11       	cpse	r24, r1
 438:	33 c0       	rjmp	.+102    	; 0x4a0 <_Z5Mergev+0x82>
		{
			if (bufferUART_RX.Count() > 0)
 43a:	86 e7       	ldi	r24, 0x76	; 118
 43c:	9f e3       	ldi	r25, 0x3F	; 63
 43e:	6c de       	rcall	.-808    	; 0x118 <_ZN10RingBufferILh32EE5CountEv>
 440:	88 23       	and	r24, r24
 442:	09 f4       	brne	.+2      	; 0x446 <_Z5Mergev+0x28>
 444:	68 c0       	rjmp	.+208    	; 0x516 <_Z5Mergev+0xf8>
			{
				status.currentChar = bufferUART_RX.Read();	
 446:	86 e7       	ldi	r24, 0x76	; 118
 448:	9f e3       	ldi	r25, 0x3F	; 63
 44a:	71 de       	rcall	.-798    	; 0x12e <_ZN10RingBufferILh32EE4ReadEv>
 44c:	80 93 5e 3f 	sts	0x3F5E, r24	; 0x803f5e <status>
				//reset timer
				TCA0.SINGLE.CNT = 0;
 450:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
 454:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
}

//Read next byte without incrementing pointers
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Peek(){
	uint8_t tempTail = tail + 1;
 458:	a6 e7       	ldi	r26, 0x76	; 118
 45a:	bf e3       	ldi	r27, 0x3F	; 63
 45c:	92 96       	adiw	r26, 0x22	; 34
 45e:	ec 91       	ld	r30, X
 460:	92 97       	sbiw	r26, 0x22	; 34
 462:	ef 5f       	subi	r30, 0xFF	; 255
	
	if (tempTail >= length)
 464:	9c 91       	ld	r25, X
 466:	e9 17       	cp	r30, r25
 468:	08 f0       	brcs	.+2      	; 0x46c <_Z5Mergev+0x4e>
	{
		tempTail = 0;
 46a:	e0 e0       	ldi	r30, 0x00	; 0
	}
	
	return buffer[tempTail];
 46c:	f0 e0       	ldi	r31, 0x00	; 0
 46e:	ea 58       	subi	r30, 0x8A	; 138
 470:	f0 4c       	sbci	r31, 0xC0	; 192
			} else {
				//No data
				return;
			}
			
			if (bufferUART_RX.Peek() > 127)
 472:	91 81       	ldd	r25, Z+1	; 0x01
 474:	99 23       	and	r25, r25
 476:	1c f4       	brge	.+6      	; 0x47e <_Z5Mergev+0x60>
			{
				//Next char is command byte
				status.currentSource = I2C;
 478:	91 e0       	ldi	r25, 0x01	; 1
 47a:	90 93 5f 3f 	sts	0x3F5F, r25	; 0x803f5f <status+0x1>
			}
			
			//Try to load character
			if (TXI2C(status.currentChar))
 47e:	00 df       	rcall	.-512    	; 0x280 <_Z5TXI2Ch>
 480:	81 11       	cpse	r24, r1
			{
				//I2C failed
				status.I2CDone = 0;
 482:	10 92 61 3f 	sts	0x3F61, r1	; 0x803f61 <status+0x3>
			}
			
			if (thruUART)
 486:	80 91 5d 3f 	lds	r24, 0x3F5D	; 0x803f5d <thruUART>
 48a:	88 23       	and	r24, r24
 48c:	09 f4       	brne	.+2      	; 0x490 <_Z5Mergev+0x72>
 48e:	43 c0       	rjmp	.+134    	; 0x516 <_Z5Mergev+0xf8>
			{
				if (UART_TX(status.currentChar))
 490:	80 91 5e 3f 	lds	r24, 0x3F5E	; 0x803f5e <status>
 494:	cc d0       	rcall	.+408    	; 0x62e <_Z7UART_TXh>
 496:	88 23       	and	r24, r24
 498:	f1 f1       	breq	.+124    	; 0x516 <_Z5Mergev+0xf8>
				{
					//Uart failed
					status.dinDone = 0;
 49a:	10 92 60 3f 	sts	0x3F60, r1	; 0x803f60 <status+0x2>
 49e:	08 95       	ret
				}
			}
			
			
		} else {
			if (I2Cbuffer_RX.Count() > 0)
 4a0:	83 e2       	ldi	r24, 0x23	; 35
 4a2:	9f e3       	ldi	r25, 0x3F	; 63
 4a4:	39 de       	rcall	.-910    	; 0x118 <_ZN10RingBufferILh32EE5CountEv>
 4a6:	88 23       	and	r24, r24
 4a8:	b1 f1       	breq	.+108    	; 0x516 <_Z5Mergev+0xf8>
			{
				status.currentChar = I2Cbuffer_RX.Read();
 4aa:	83 e2       	ldi	r24, 0x23	; 35
 4ac:	9f e3       	ldi	r25, 0x3F	; 63
 4ae:	3f de       	rcall	.-898    	; 0x12e <_ZN10RingBufferILh32EE4ReadEv>
 4b0:	80 93 5e 3f 	sts	0x3F5E, r24	; 0x803f5e <status>
				//reset timer
				TCA0.SINGLE.CNT = 0;
 4b4:	10 92 20 0a 	sts	0x0A20, r1	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
 4b8:	10 92 21 0a 	sts	0x0A21, r1	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
}

//Read next byte without incrementing pointers
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Peek(){
	uint8_t tempTail = tail + 1;
 4bc:	a3 e2       	ldi	r26, 0x23	; 35
 4be:	bf e3       	ldi	r27, 0x3F	; 63
 4c0:	92 96       	adiw	r26, 0x22	; 34
 4c2:	ec 91       	ld	r30, X
 4c4:	92 97       	sbiw	r26, 0x22	; 34
 4c6:	ef 5f       	subi	r30, 0xFF	; 255
	
	if (tempTail >= length)
 4c8:	9c 91       	ld	r25, X
 4ca:	e9 17       	cp	r30, r25
 4cc:	08 f0       	brcs	.+2      	; 0x4d0 <_Z5Mergev+0xb2>
	{
		tempTail = 0;
 4ce:	e0 e0       	ldi	r30, 0x00	; 0
	}
	
	return buffer[tempTail];
 4d0:	f0 e0       	ldi	r31, 0x00	; 0
 4d2:	ed 5d       	subi	r30, 0xDD	; 221
 4d4:	f0 4c       	sbci	r31, 0xC0	; 192
			} else {
				//No data
				return;
			}
			
			if (I2Cbuffer_RX.Peek() > 127)
 4d6:	91 81       	ldd	r25, Z+1	; 0x01
 4d8:	99 23       	and	r25, r25
 4da:	14 f4       	brge	.+4      	; 0x4e0 <_Z5Mergev+0xc2>
			{
				//Next char is command byte
				status.currentSource = DIN5;
 4dc:	10 92 5f 3f 	sts	0x3F5F, r1	; 0x803f5f <status+0x1>
			}
			
			//Try to load character
			if (UART_TX(status.currentChar))
 4e0:	a6 d0       	rcall	.+332    	; 0x62e <_Z7UART_TXh>
 4e2:	88 23       	and	r24, r24
 4e4:	c1 f0       	breq	.+48     	; 0x516 <_Z5Mergev+0xf8>
			{
				//Uart failed
				status.dinDone = 0;
 4e6:	10 92 60 3f 	sts	0x3F60, r1	; 0x803f60 <status+0x2>
 4ea:	08 95       	ret
			}
		}
			
	} else if (!status.I2CDone) {
 4ec:	80 91 61 3f 	lds	r24, 0x3F61	; 0x803f61 <status+0x3>
 4f0:	81 11       	cpse	r24, r1
 4f2:	09 c0       	rjmp	.+18     	; 0x506 <_Z5Mergev+0xe8>
		if (!TXI2C(status.currentChar))
 4f4:	80 91 5e 3f 	lds	r24, 0x3F5E	; 0x803f5e <status>
 4f8:	c3 de       	rcall	.-634    	; 0x280 <_Z5TXI2Ch>
 4fa:	81 11       	cpse	r24, r1
 4fc:	0c c0       	rjmp	.+24     	; 0x516 <_Z5Mergev+0xf8>
		{
			status.I2CDone = 1;
 4fe:	81 e0       	ldi	r24, 0x01	; 1
 500:	80 93 61 3f 	sts	0x3F61, r24	; 0x803f61 <status+0x3>
 504:	08 95       	ret
		}
	} else {
		if (!UART_TX(status.currentChar))
 506:	80 91 5e 3f 	lds	r24, 0x3F5E	; 0x803f5e <status>
 50a:	91 d0       	rcall	.+290    	; 0x62e <_Z7UART_TXh>
 50c:	81 11       	cpse	r24, r1
 50e:	03 c0       	rjmp	.+6      	; 0x516 <_Z5Mergev+0xf8>
		{
			status.dinDone = 1;
 510:	81 e0       	ldi	r24, 0x01	; 1
 512:	80 93 60 3f 	sts	0x3F60, r24	; 0x803f60 <status+0x2>
 516:	08 95       	ret

00000518 <main>:
struct MergeStatus status;
volatile uint8_t thruUART = 0;

int main(void)
{
	CLK_Init();
 518:	54 df       	rcall	.-344    	; 0x3c2 <_Z8CLK_Initv>
	Timer_Init();
 51a:	5b df       	rcall	.-330    	; 0x3d2 <_Z10Timer_Initv>
	UART_Init();
 51c:	28 d0       	rcall	.+80     	; 0x56e <_Z9UART_Initv>
	I2C_Init();
 51e:	a7 dd       	rcall	.-1202   	; 0x6e <_Z8I2C_Initv>
	Led_Init();
 520:	01 df       	rcall	.-510    	; 0x324 <_Z8Led_Initv>
	
	//Set button pullup
	//PORTB.PIN2CTRL = PORT_PULLUPEN_bm;
	
	//Set LEDS as output
	PORTB.DIRSET = PIN4_bm;
 522:	80 e1       	ldi	r24, 0x10	; 16
 524:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <__TEXT_REGION_LENGTH__+0x700421>
	PORTA.DIRSET = PIN7_bm;
 528:	80 e8       	ldi	r24, 0x80	; 128
 52a:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <__TEXT_REGION_LENGTH__+0x700401>
	
	status.currentSource = DIN5;
 52e:	ee e5       	ldi	r30, 0x5E	; 94
 530:	ff e3       	ldi	r31, 0x3F	; 63
 532:	11 82       	std	Z+1, r1	; 0x01
	status.dinDone = 1;
 534:	81 e0       	ldi	r24, 0x01	; 1
 536:	82 83       	std	Z+2, r24	; 0x02
	status.I2CDone = 1;
 538:	83 83       	std	Z+3, r24	; 0x03
	
	sei();
 53a:	78 94       	sei
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 53c:	2f e7       	ldi	r18, 0x7F	; 127
 53e:	8f e4       	ldi	r24, 0x4F	; 79
 540:	92 e1       	ldi	r25, 0x12	; 18
 542:	21 50       	subi	r18, 0x01	; 1
 544:	80 40       	sbci	r24, 0x00	; 0
 546:	90 40       	sbci	r25, 0x00	; 0
 548:	e1 f7       	brne	.-8      	; 0x542 <main+0x2a>
 54a:	00 c0       	rjmp	.+0      	; 0x54c <main+0x34>
 54c:	00 00       	nop
	
	_delay_ms(300);
	
	TXI2C('L');
 54e:	8c e4       	ldi	r24, 0x4C	; 76
 550:	97 de       	rcall	.-722    	; 0x280 <_Z5TXI2Ch>
	WordReady(1);
 552:	81 e0       	ldi	r24, 0x01	; 1
 554:	b5 dd       	rcall	.-1174   	; 0xc0 <_Z9WordReadyh>
	
    while (1) 
    {
		thruUART = PORTB.IN & PIN2_bm;	//Insert button here
 556:	c0 e2       	ldi	r28, 0x20	; 32
 558:	d4 e0       	ldi	r29, 0x04	; 4
 55a:	88 85       	ldd	r24, Y+8	; 0x08
 55c:	84 70       	andi	r24, 0x04	; 4
 55e:	80 93 5d 3f 	sts	0x3F5D, r24	; 0x803f5d <thruUART>
		Merge();
 562:	5d df       	rcall	.-326    	; 0x41e <_Z5Mergev>
		
		if (WordCountI2C() > 0)
 564:	a9 dd       	rcall	.-1198   	; 0xb8 <_Z12WordCountI2Cv>
 566:	88 23       	and	r24, r24
 568:	c1 f3       	breq	.-16     	; 0x55a <main+0x42>
		{
			StartTransmission();
 56a:	0e de       	rcall	.-996    	; 0x188 <_Z17StartTransmissionv>
 56c:	f6 cf       	rjmp	.-20     	; 0x55a <main+0x42>

0000056e <_Z9UART_Initv>:
//Does not work

#define MIDIRate (4*F_CPU/31250)

void UART_Init(){
	PORTMUX.CTRLB = PORTMUX_USART0_DEFAULT_gc;
 56e:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
	
	//Invert output
	PORTB.PIN2CTRL = PORT_INVEN_bm;
 572:	e0 e2       	ldi	r30, 0x20	; 32
 574:	f4 e0       	ldi	r31, 0x04	; 4
 576:	80 e8       	ldi	r24, 0x80	; 128
 578:	82 8b       	std	Z+18, r24	; 0x12
	
	//Configure output pin
	PORTB.DIRSET = PIN2_bm;
 57a:	94 e0       	ldi	r25, 0x04	; 4
 57c:	91 83       	std	Z+1, r25	; 0x01
	PORTB.OUTSET = PIN2_bm;
 57e:	95 83       	std	Z+5, r25	; 0x05
	
	//Set Baudrate = 31250Hz
	//USART0.BAUD = MIDIRate;
	USART0_BAUD = MIDIRate;
 580:	20 e0       	ldi	r18, 0x00	; 0
 582:	3a e0       	ldi	r19, 0x0A	; 10
 584:	20 93 08 08 	sts	0x0808, r18	; 0x800808 <__TEXT_REGION_LENGTH__+0x700808>
 588:	30 93 09 08 	sts	0x0809, r19	; 0x800809 <__TEXT_REGION_LENGTH__+0x700809>
	
	//USART0.DBGCTRL = Debug;
	USART0_DBGCTRL = Debug;
 58c:	91 e0       	ldi	r25, 0x01	; 1
 58e:	90 93 0b 08 	sts	0x080B, r25	; 0x80080b <__TEXT_REGION_LENGTH__+0x70080b>
	
	//Set frame format: 8bit, 1stop
	//USART0.CTRLC = USART_CHSIZE_8BIT_gc|USART_CMODE_ASYNCHRONOUS_gc;
	USART0_CTRLC = USART_CHSIZE_8BIT_gc|USART_CMODE_ASYNCHRONOUS_gc;
 592:	93 e0       	ldi	r25, 0x03	; 3
 594:	90 93 07 08 	sts	0x0807, r25	; 0x800807 <__TEXT_REGION_LENGTH__+0x700807>
	
	//Invert input?
	//PORTB.PIN3CTRL = PORT_INVEN_bm;
	PORTB.DIRCLR = PIN3_bm;
 598:	98 e0       	ldi	r25, 0x08	; 8
 59a:	92 83       	std	Z+2, r25	; 0x02
	
	//Enable RX interrupt
	//USART0.CTRLA = USART_RXCIE_bm;
	USART0_CTRLA = USART_RXCIE_bm;
 59c:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <__TEXT_REGION_LENGTH__+0x700805>
	
	//Enable RX and TX
	//USART0.CTRLB = USART_RXEN_bm|USART_TXEN_bm;
	USART0_CTRLB = USART_RXEN_bm|USART_TXEN_bm;
 5a0:	80 ec       	ldi	r24, 0xC0	; 192
 5a2:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <__TEXT_REGION_LENGTH__+0x700806>
 5a6:	08 95       	ret

000005a8 <__vector_22>:
	//USART0.CTRLA |= USART_DREIE_bm;
	USART0_CTRLA |= USART_DREIE_bm;
	return 0;
}

ISR(USART0_RXC_vect){
 5a8:	1f 92       	push	r1
 5aa:	0f 92       	push	r0
 5ac:	0f b6       	in	r0, 0x3f	; 63
 5ae:	0f 92       	push	r0
 5b0:	11 24       	eor	r1, r1
 5b2:	2f 93       	push	r18
 5b4:	3f 93       	push	r19
 5b6:	4f 93       	push	r20
 5b8:	5f 93       	push	r21
 5ba:	6f 93       	push	r22
 5bc:	8f 93       	push	r24
 5be:	9f 93       	push	r25
 5c0:	ef 93       	push	r30
 5c2:	ff 93       	push	r31
	//uint8_t rx = USART0.RXDATAL;
	uint8_t rx = USART0_RXDATAL;
 5c4:	60 91 00 08 	lds	r22, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>

//Returns how many elements are in the buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Count(){
	//Compensate for overflows
	if (head >= tail)
 5c8:	e6 e7       	ldi	r30, 0x76	; 118
 5ca:	ff e3       	ldi	r31, 0x3F	; 63
 5cc:	21 a1       	ldd	r18, Z+33	; 0x21
 5ce:	92 a1       	ldd	r25, Z+34	; 0x22
 5d0:	29 17       	cp	r18, r25
 5d2:	18 f0       	brcs	.+6      	; 0x5da <__vector_22+0x32>
	{
		return (head - tail);
 5d4:	82 2f       	mov	r24, r18
 5d6:	89 1b       	sub	r24, r25
 5d8:	04 c0       	rjmp	.+8      	; 0x5e2 <__vector_22+0x3a>
	} else {
		return (head - tail + length);
 5da:	80 91 76 3f 	lds	r24, 0x3F76	; 0x803f76 <bufferUART_RX>
 5de:	82 0f       	add	r24, r18
 5e0:	89 1b       	sub	r24, r25
}

//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
 5e2:	30 91 76 3f 	lds	r19, 0x3F76	; 0x803f76 <bufferUART_RX>
 5e6:	90 e0       	ldi	r25, 0x00	; 0
 5e8:	43 2f       	mov	r20, r19
 5ea:	50 e0       	ldi	r21, 0x00	; 0
 5ec:	42 50       	subi	r20, 0x02	; 2
 5ee:	51 09       	sbc	r21, r1
 5f0:	84 17       	cp	r24, r20
 5f2:	95 07       	cpc	r25, r21
 5f4:	74 f4       	brge	.+28     	; 0x612 <__vector_22+0x6a>
	{
		head++;
 5f6:	2f 5f       	subi	r18, 0xFF	; 255
		
		if (head >= length)
 5f8:	23 17       	cp	r18, r19
 5fa:	18 f4       	brcc	.+6      	; 0x602 <__vector_22+0x5a>
//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
	{
		head++;
 5fc:	20 93 97 3f 	sts	0x3F97, r18	; 0x803f97 <bufferUART_RX+0x21>
 600:	02 c0       	rjmp	.+4      	; 0x606 <__vector_22+0x5e>
		
		if (head >= length)
		{
			head = 0;
 602:	10 92 97 3f 	sts	0x3F97, r1	; 0x803f97 <bufferUART_RX+0x21>
		}
		
		buffer[head] = in;
 606:	e0 91 97 3f 	lds	r30, 0x3F97	; 0x803f97 <bufferUART_RX+0x21>
 60a:	f0 e0       	ldi	r31, 0x00	; 0
 60c:	ea 58       	subi	r30, 0x8A	; 138
 60e:	f0 4c       	sbci	r31, 0xC0	; 192
 610:	61 83       	std	Z+1, r22	; 0x01
	bufferUART_RX.Write(rx);
}
 612:	ff 91       	pop	r31
 614:	ef 91       	pop	r30
 616:	9f 91       	pop	r25
 618:	8f 91       	pop	r24
 61a:	6f 91       	pop	r22
 61c:	5f 91       	pop	r21
 61e:	4f 91       	pop	r20
 620:	3f 91       	pop	r19
 622:	2f 91       	pop	r18
 624:	0f 90       	pop	r0
 626:	0f be       	out	0x3f, r0	; 63
 628:	0f 90       	pop	r0
 62a:	1f 90       	pop	r1
 62c:	18 95       	reti

0000062e <_Z7UART_TXh>:
	//Enable RX and TX
	//USART0.CTRLB = USART_RXEN_bm|USART_TXEN_bm;
	USART0_CTRLB = USART_RXEN_bm|USART_TXEN_bm;
}

uint8_t UART_TX(uint8_t msg){
 62e:	cf 93       	push	r28
 630:	c8 2f       	mov	r28, r24
	if (bufferUART_TX.Count() > 254)
 632:	83 e6       	ldi	r24, 0x63	; 99
 634:	9f e3       	ldi	r25, 0x3F	; 63
 636:	35 dd       	rcall	.-1430   	; 0xa2 <_ZN10RingBufferILh16EE5CountEv>
 638:	8f 3f       	cpi	r24, 0xFF	; 255
 63a:	09 f1       	breq	.+66     	; 0x67e <_Z7UART_TXh+0x50>
}

//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
 63c:	40 91 63 3f 	lds	r20, 0x3F63	; 0x803f63 <bufferUART_TX>
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	24 2f       	mov	r18, r20
 644:	30 e0       	ldi	r19, 0x00	; 0
 646:	22 50       	subi	r18, 0x02	; 2
 648:	31 09       	sbc	r19, r1
 64a:	82 17       	cp	r24, r18
 64c:	93 07       	cpc	r25, r19
 64e:	84 f4       	brge	.+32     	; 0x670 <_Z7UART_TXh+0x42>
	{
		head++;
 650:	80 91 74 3f 	lds	r24, 0x3F74	; 0x803f74 <bufferUART_TX+0x11>
 654:	8f 5f       	subi	r24, 0xFF	; 255
		
		if (head >= length)
 656:	84 17       	cp	r24, r20
 658:	18 f4       	brcc	.+6      	; 0x660 <_Z7UART_TXh+0x32>
//Write a byte to the buffer
template <uint8_t BUFFER_SIZE>
void RingBuffer<BUFFER_SIZE>::Write(uint8_t in){
	if (Count() < length - 2)
	{
		head++;
 65a:	80 93 74 3f 	sts	0x3F74, r24	; 0x803f74 <bufferUART_TX+0x11>
 65e:	02 c0       	rjmp	.+4      	; 0x664 <_Z7UART_TXh+0x36>
		
		if (head >= length)
		{
			head = 0;
 660:	10 92 74 3f 	sts	0x3F74, r1	; 0x803f74 <bufferUART_TX+0x11>
		}
		
		buffer[head] = in;
 664:	e0 91 74 3f 	lds	r30, 0x3F74	; 0x803f74 <bufferUART_TX+0x11>
 668:	f0 e0       	ldi	r31, 0x00	; 0
 66a:	ed 59       	subi	r30, 0x9D	; 157
 66c:	f0 4c       	sbci	r31, 0xC0	; 192
 66e:	c1 83       	std	Z+1, r28	; 0x01
	}
	bufferUART_TX.Write(msg);
	
	//Enable interrupt
	//USART0.CTRLA |= USART_DREIE_bm;
	USART0_CTRLA |= USART_DREIE_bm;
 670:	e5 e0       	ldi	r30, 0x05	; 5
 672:	f8 e0       	ldi	r31, 0x08	; 8
 674:	80 81       	ld	r24, Z
 676:	80 62       	ori	r24, 0x20	; 32
 678:	80 83       	st	Z, r24
	return 0;
 67a:	80 e0       	ldi	r24, 0x00	; 0
 67c:	01 c0       	rjmp	.+2      	; 0x680 <_Z7UART_TXh+0x52>
}

uint8_t UART_TX(uint8_t msg){
	if (bufferUART_TX.Count() > 254)
	{
		return 1;
 67e:	81 e0       	ldi	r24, 0x01	; 1
	
	//Enable interrupt
	//USART0.CTRLA |= USART_DREIE_bm;
	USART0_CTRLA |= USART_DREIE_bm;
	return 0;
}
 680:	cf 91       	pop	r28
 682:	08 95       	ret

00000684 <__vector_23>:
	//uint8_t rx = USART0.RXDATAL;
	uint8_t rx = USART0_RXDATAL;
	bufferUART_RX.Write(rx);
}

ISR(USART0_DRE_vect){
 684:	1f 92       	push	r1
 686:	0f 92       	push	r0
 688:	0f b6       	in	r0, 0x3f	; 63
 68a:	0f 92       	push	r0
 68c:	11 24       	eor	r1, r1
 68e:	2f 93       	push	r18
 690:	3f 93       	push	r19
 692:	4f 93       	push	r20
 694:	5f 93       	push	r21
 696:	6f 93       	push	r22
 698:	7f 93       	push	r23
 69a:	8f 93       	push	r24
 69c:	9f 93       	push	r25
 69e:	af 93       	push	r26
 6a0:	bf 93       	push	r27
 6a2:	ef 93       	push	r30
 6a4:	ff 93       	push	r31
	if (bufferUART_TX.Count() > 0)
 6a6:	83 e6       	ldi	r24, 0x63	; 99
 6a8:	9f e3       	ldi	r25, 0x3F	; 63
 6aa:	fb dc       	rcall	.-1546   	; 0xa2 <_ZN10RingBufferILh16EE5CountEv>
 6ac:	88 23       	and	r24, r24
 6ae:	a1 f0       	breq	.+40     	; 0x6d8 <__vector_23+0x54>
//Read the next byte in buffer
template <uint8_t BUFFER_SIZE>
uint8_t RingBuffer<BUFFER_SIZE>::Read(){
	if (Count() > 0)
	{
		tail++;
 6b0:	e3 e6       	ldi	r30, 0x63	; 99
 6b2:	ff e3       	ldi	r31, 0x3F	; 63
 6b4:	82 89       	ldd	r24, Z+18	; 0x12
 6b6:	8f 5f       	subi	r24, 0xFF	; 255
 6b8:	82 8b       	std	Z+18, r24	; 0x12
		if (tail >= length)
 6ba:	90 81       	ld	r25, Z
 6bc:	89 17       	cp	r24, r25
 6be:	10 f0       	brcs	.+4      	; 0x6c4 <__vector_23+0x40>
		{
			tail = 0;
 6c0:	10 92 75 3f 	sts	0x3F75, r1	; 0x803f75 <bufferUART_TX+0x12>
		}
		return buffer[tail];
 6c4:	e0 91 75 3f 	lds	r30, 0x3F75	; 0x803f75 <bufferUART_TX+0x12>
 6c8:	f0 e0       	ldi	r31, 0x00	; 0
 6ca:	ed 59       	subi	r30, 0x9D	; 157
 6cc:	f0 4c       	sbci	r31, 0xC0	; 192
 6ce:	81 81       	ldd	r24, Z+1	; 0x01
	{
		//USART0.TXDATAL = bufferUART_TX.Read();
		USART0_TXDATAL = bufferUART_TX.Read();
 6d0:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
		UART_Activity();
 6d4:	47 de       	rcall	.-882    	; 0x364 <_Z13UART_Activityv>
 6d6:	05 c0       	rjmp	.+10     	; 0x6e2 <__vector_23+0x5e>
	} else {
		//Disable interrupt if send register is empty
		//USART0.CTRLA &= ~(USART_DREIE_bm);
		USART0_CTRLA &= ~(USART_DREIE_bm);
 6d8:	e5 e0       	ldi	r30, 0x05	; 5
 6da:	f8 e0       	ldi	r31, 0x08	; 8
 6dc:	80 81       	ld	r24, Z
 6de:	8f 7d       	andi	r24, 0xDF	; 223
 6e0:	80 83       	st	Z, r24
	}
}
 6e2:	ff 91       	pop	r31
 6e4:	ef 91       	pop	r30
 6e6:	bf 91       	pop	r27
 6e8:	af 91       	pop	r26
 6ea:	9f 91       	pop	r25
 6ec:	8f 91       	pop	r24
 6ee:	7f 91       	pop	r23
 6f0:	6f 91       	pop	r22
 6f2:	5f 91       	pop	r21
 6f4:	4f 91       	pop	r20
 6f6:	3f 91       	pop	r19
 6f8:	2f 91       	pop	r18
 6fa:	0f 90       	pop	r0
 6fc:	0f be       	out	0x3f, r0	; 63
 6fe:	0f 90       	pop	r0
 700:	1f 90       	pop	r1
 702:	18 95       	reti

00000704 <_GLOBAL__sub_I_bufferUART_RX>:

#ifndef RINGBUFFER_H_
#define RINGBUFFER_H_

template <uint8_t BUFFER_SIZE>
class RingBuffer
 704:	e6 e7       	ldi	r30, 0x76	; 118
 706:	ff e3       	ldi	r31, 0x3F	; 63
 708:	80 e2       	ldi	r24, 0x20	; 32
 70a:	80 83       	st	Z, r24
 70c:	11 a2       	std	Z+33, r1	; 0x21
 70e:	12 a2       	std	Z+34, r1	; 0x22
 710:	e3 e6       	ldi	r30, 0x63	; 99
 712:	ff e3       	ldi	r31, 0x3F	; 63
 714:	80 e1       	ldi	r24, 0x10	; 16
 716:	80 83       	st	Z, r24
 718:	11 8a       	std	Z+17, r1	; 0x11
 71a:	12 8a       	std	Z+18, r1	; 0x12
 71c:	08 95       	ret

0000071e <__tablejump2__>:
 71e:	ee 0f       	add	r30, r30
 720:	ff 1f       	adc	r31, r31
 722:	05 90       	lpm	r0, Z+
 724:	f4 91       	lpm	r31, Z
 726:	e0 2d       	mov	r30, r0
 728:	09 94       	ijmp

0000072a <_exit>:
 72a:	f8 94       	cli

0000072c <__stop_program>:
 72c:	ff cf       	rjmp	.-2      	; 0x72c <__stop_program>
